<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur Carte OSM (Vectoriel)</title>

    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Plugin Recherche (GeoSearch) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

    <!-- Leaflet Draw CSS & JS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

    <!-- Turf.js for Geometry -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            --primary: #c026d3;
            /* fuchsia-600 */
            --primary-hover: #a21caf;
            /* fuchsia-700 */
            --primary-light: #f5d0fe;
            /* fuchsia-200 */
            --text: #0f172a;
            /* slate-900 */
            --text-muted: #64748b;
            /* slate-500 */
            --surface: rgba(255, 255, 255, 0.85);
            --surface-glass: rgba(255, 255, 255, 0.7);
            --border: rgba(255, 255, 255, 0.3);
            --shadow: rgba(0, 0, 0, 0.1);
            --background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            height: 100vh;
            display: flex;
            background: var(--background);
            color: var(--text);
            overflow: hidden;
        }

        /* Glassmorphism Sidebar */
        #sidebar {
            width: 400px;
            background: var(--surface-glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-right: 1px solid var(--border);
            box-shadow: 4px 0 30px var(--shadow);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            padding: 24px;
            overflow-y: auto;
        }

        #sidebar::-webkit-scrollbar {
            width: 6px;
        }

        #sidebar::-webkit-scrollbar-thumb {
            background: var(--primary-light);
            border-radius: 3px;
        }

        h1 {
            font-size: 1.5rem;
            margin: 0 0 4px 0;
            background: linear-gradient(135deg, var(--primary) 0%, #7c3aed 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
        }

        h3 {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text);
            margin: 0 0 12px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group {
            margin-bottom: 20px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .info {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 6px;
            line-height: 1.5;
        }

        /* Buttons */
        button {
            background: linear-gradient(135deg, var(--primary) 0%, #9333ea 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            width: 100%;
            transition: all 0.3s ease;
            margin-bottom: 8px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(192, 38, 211, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(192, 38, 211, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: rgba(255, 255, 255, 0.8);
            color: var(--text);
            box-shadow: 0 2px 10px var(--shadow);
        }

        button.secondary:hover {
            background: rgba(255, 255, 255, 1);
        }

        /* Layer List */
        .layer-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.9rem;
            cursor: pointer;
            padding: 10px 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .layer-item:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: var(--primary-light);
        }

        .layer-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .badge {
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 20px;
            background: var(--primary-light);
            color: var(--primary);
            font-weight: 600;
            margin-left: auto;
        }

        /* Inputs */
        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            font-size: 0.9rem;
            background: rgba(255, 255, 255, 0.8);
            color: var(--text);
            transition: all 0.2s ease;
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(192, 38, 211, 0.1);
        }

        label {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text);
            display: block;
            margin-bottom: 6px;
        }

        /* Map */
        #map {
            flex-grow: 1;
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        /* Search Bar Floating */
        .search-container {
            position: absolute;
            top: 20px;
            left: 420px;
            z-index: 1000;
            width: 350px;
        }

        .search-input {
            width: 100%;
            padding: 14px 20px;
            border: none;
            border-radius: 12px;
            font-size: 0.95rem;
            background: var(--surface-glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 4px 20px var(--shadow);
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            box-shadow: 0 4px 25px rgba(192, 38, 211, 0.2);
        }

        .search-input::placeholder {
            color: var(--text-muted);
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--surface);
            border-radius: 12px;
            margin-top: 8px;
            box-shadow: 0 4px 20px var(--shadow);
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }

        .search-results.active {
            display: block;
        }

        .search-result-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            transition: background 0.2s;
        }

        .search-result-item:hover {
            background: var(--primary-light);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        /* Status */
        #global-status {
            padding: 12px 16px;
            border-radius: 8px;
            background: linear-gradient(135deg, var(--primary-light) 0%, #e9d5ff 100%);
            color: var(--primary);
            font-weight: 600;
            font-size: 0.85rem;
            text-align: center;
            margin-top: 8px;
        }

        #global-status.loading {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        /* Geocoder Override */
        .leaflet-control-geocoder {
            display: none !important;
        }

        /* Version Badge */
        .version-badge {
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 16px;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            display: inline-block;
        }
    </style>
</head>

<body>

    <div id="sidebar">
        <h1>LaserMap Studio ‚¨†</h1>
        <div class="version-badge">Version 32 ‚Ä¢ Pro</div>

        <!-- Nom du Projet -->
        <div class="control-group">
            <h3>üìÅ Projet</h3>
            <label>Nom du Projet</label>
            <input type="text" id="projectName" placeholder="Ex: Paris 12e...">
        </div>

        <div class="control-group">
            <h3>üìç Zone</h3>
            <div class="info">Dessinez une forme sur la carte ou utilisez la barre de recherche.</div>
        </div>

        <div class="control-group">
            <h3>2. Zone de D√©coupe</h3>
            <div style="display: flex; gap: 8px; margin-bottom:12px;">
                <button onclick="initPentagon()">
                    ‚¨† Pentagone
                </button>
                <button onclick="drawRectangle()" class="secondary">
                    ‚¨õ Rectangle
                </button>
                <button onclick="initCircle()" class="secondary">
                    ‚¨§ Cercle
                </button>
            </div>

            <!-- Slider Taille -->
            <div style="margin-top: 5px;">
                <div style="display:flex; justify-content:space-between;">
                    <label style="font-size: 0.9rem; font-weight: 600;">Taille</label>
                    <span id="radiusVal" style="font-size: 0.8rem; color:#666;">2.0 km</span>
                </div>
                <input type="range" id="radiusInput" min="500" max="15000" step="100" value="2000"
                    style="width: 100%; accent-color: #d946ef;" oninput="updatePentagonTransform()">
            </div>

            <!-- Slider Rotation -->
            <div style="margin-top: 10px;">
                <div style="display:flex; justify-content:space-between;">
                    <label style="font-size: 0.9rem; font-weight: 600;">Rotation</label>
                    <span id="rotVal" style="font-size: 0.8rem; color:#666;">0¬∞</span>
                </div>
                <input type="range" id="rotInput" min="0" max="360" step="5" value="0"
                    style="width: 100%; accent-color: #d946ef;" oninput="updatePentagonTransform()">
            </div>

            <div id="zone-status" class="info" style="color: red;">Aucune zone dessin√©e.</div>
        </div>

        <div class="control-group">
            <h3>3. S√©lectionner les Couches</h3>
            <div class="info" style="margin-bottom:10px;">
                Cochez les √©l√©ments √† inclure dans le t√©l√©chargement.
            </div>

            <div class="layer-list">
                <label class="layer-item">
                    <input type="checkbox" id="chk_routes_grands" checked>
                    <span>üõ£Ô∏è Autoroutes & Nationales</span>
                    <span class="badge">√âpais</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_routes_secondaires" checked>
                    <span>üöó Routes Principales</span>
                    <span class="badge">Moyen</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_routes_locales" checked>
                    <span>üèòÔ∏è Rues Locales</span>
                    <span class="badge">Fin</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_eau" checked>
                    <span>üíß Fleuves & Lacs</span>
                    <span class="badge">Rempli</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_bati" checked>
                    <span>üè¢ B√¢timents</span>
                    <span class="badge">Lourd</span>
                </label>
            </div>

            <!-- Options Export -->
            <div style="margin-top:20px; border-top:1px solid #ddd; padding-top:10px;">
                <label style="font-size:0.9rem; display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="chk_merge" checked style="accent-color:#d946ef; margin-right:8px;">
                    Fusionner les trac√©s (1 objet/calque)
                </label>

                <!-- V26: Mode Trac√© (Axe vs Surface) -->
                <div style="margin-top:10px;">
                    <label style="font-size:0.8rem; font-weight:600;">G√©om√©trie des Routes</label>
                    <select id="roadMode" style="width:100%; padding:4px; margin-top:4px;">
                        <option value="surface">üõ£Ô∏è Bande Physique (Double trait/Surface)</option>
                        <option value="centerline">üìç Axe Central (Trait unique)</option>
                    </select>
                </div>

                <!-- V21: Dimensions Physiques -->
                <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; margin-top:10px;">
                    <div>
                        <label style="font-size:0.8rem; font-weight:600;">Largeur (cm)</label>
                        <input type="number" id="exportWidth" value="10" min="1" max="100"
                            style="width:100%; padding:4px;">
                    </div>
                    <div>
                        <label style="font-size:0.8rem; font-weight:600;">√âpaisseur (mm)</label>
                        <input type="number" id="roadThick" value="4" min="0.1" max="20" step="0.1"
                            style="width:100%; padding:4px;">
                    </div>
                    <div>
                        <label style="font-size:0.8rem; font-weight:600;">Marge Cadre (mm)</label>
                        <input type="number" id="frameMargin" value="5" min="0" max="50" step="1"
                            style="width:100%; padding:4px;"
                            title="Taille du pentagone externe pour l'op√©ration Diff√©rence">
                    </div>
                </div>

                <!-- V23: Style export -->
                <div style="margin-top:10px;">
                    <label style="font-size:0.8rem; font-weight:600;">Style de Rendu</label>
                    <select id="renderStyle" style="width:100%; padding:4px; margin-top:4px;">
                        <option value="stroke">‚≠ï Contour (D√©coupe Vectorielle)</option>
                        <option value="fill">‚¨õ Remplissage (Surface/Gravure)</option>
                    </select>
                </div>
            </div>

            <button onclick="downloadSelectedLayers()"
                style="width: 100%; margin-top: 20px; padding: 12px; background: #d946ef; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                T√©l√©charger SVG (Batch)
            </button>

            <div id="global-status" class="info" style="font-weight: bold; color: var(--primary); margin-top:10px;">
            </div>
        </div>

        <div class="control-group">
            <h3>4. Rendu Visuel</h3>
            <div style="display:flex; gap:10px">
                <button class="secondary" onclick="setLayer('light')">Blanc</button>
                <button class="secondary" onclick="setLayer('dark')">Noir</button>
            </div>
        </div>

    </div>

    <!-- Floating Search Bar -->
    <div class="search-container">
        <input type="text" class="search-input" id="searchInput" placeholder="üîç Rechercher une adresse...">
        <div class="search-results" id="searchResults"></div>
    </div>

    <div id="map"></div>

    <script>
        // Init Map
        const map = L.map('map').setView([48.8566, 2.3522], 13);

        // Layers
        const layers = {
            osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM' }),
            light: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; CartoDB' }),
            dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; CartoDB' })
        };
        layers.light.addTo(map);

        function setLayer(name) {
            map.eachLayer(layer => {
                if (layer._url) map.removeLayer(layer);
            });
            layers[name].addTo(map);
        }

        // V32: Custom Address Search (Nominatim)
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        let searchTimeout = null;

        searchInput.addEventListener('input', function () {
            clearTimeout(searchTimeout);
            const query = this.value.trim();

            if (query.length < 3) {
                searchResults.classList.remove('active');
                return;
            }

            searchTimeout = setTimeout(async () => {
                try {
                    const resp = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=5&countrycodes=fr,be,ch,lu`);
                    const results = await resp.json();

                    searchResults.innerHTML = '';
                    if (results.length > 0) {
                        results.forEach(result => {
                            const item = document.createElement('div');
                            item.className = 'search-result-item';
                            item.textContent = result.display_name;
                            item.addEventListener('click', () => {
                                map.setView([parseFloat(result.lat), parseFloat(result.lon)], 15);
                                searchResults.classList.remove('active');
                                searchInput.value = result.display_name.split(',')[0];
                            });
                            searchResults.appendChild(item);
                        });
                        searchResults.classList.add('active');
                    } else {
                        searchResults.classList.remove('active');
                    }
                } catch (e) {
                    console.error('Search error:', e);
                }
            }, 300);
        });

        // Close results on click outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                searchResults.classList.remove('active');
            }
        });

        // --- DRAW FEATURE ---
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        let selectedBounds = null;
        let selectedShapeLayer = null;
        let isPentagonActive = false;
        let pentagonCenter = null;

        function drawRectangle() {
            isPentagonActive = false;
            isCircleActive = false;
            pentagonCenter = null;
            circleCenter = null;
            new L.Draw.Rectangle(map, { shapeOptions: { color: '#2563eb' } }).enable();
        }

        function initPentagon() {
            isPentagonActive = true;
            isCircleActive = false;
            circleCenter = null;
            const center = map.getCenter();
            drawPentagon(center);
        }

        // --- PENTAGON LOGIC (RESIZABLE + ROTATABLE) ---
        function drawPentagon(center) {
            drawnItems.clearLayers();
            pentagonCenter = center;
            circleCenter = null;
            isCircleActive = false;

            // Radius from slider
            const rMeters = parseInt(document.getElementById('radiusInput').value);
            const radiusDeg = rMeters / 111320;

            // Rotation from slider (deg -> rad)
            const rotDeg = parseInt(document.getElementById('rotInput').value);
            const rotRad = rotDeg * (Math.PI / 180);

            const points = [];
            const sides = 5;
            const baseRot = -Math.PI / 2; // Point up default

            for (let i = 0; i < sides; i++) {
                const angle = (i * 2 * Math.PI) / sides + baseRot + rotRad;
                const latOffset = radiusDeg * Math.sin(angle);
                const lonOffset = (radiusDeg * Math.cos(angle)) / Math.cos(center.lat * Math.PI / 180);

                points.push([center.lat + latOffset, center.lng + lonOffset]);
            }
            const polygon = L.polygon(points, { color: '#c026d3', weight: 3, fillOpacity: 0.1 });
            drawnItems.addLayer(polygon);
            selectedShapeLayer = polygon;
            selectedBounds = polygon.getBounds();

            isPentagonActive = true;
            document.getElementById('zone-status').innerHTML = "‚¨† Pentagone Actif (" + (rMeters / 1000) + "km)";
            document.getElementById('zone-status').style.color = "#c026d3";
        }

        // --- CIRCLE LOGIC (RESIZABLE) ---
        let isCircleActive = false;
        let circleCenter = null;

        function initCircle() {
            isPentagonActive = false;
            pentagonCenter = null;
            isCircleActive = true;
            document.getElementById('zone-status').innerHTML = "‚¨§ Cliquez sur la carte pour placer le cercle";
            document.getElementById('zone-status').style.color = "#c026d3";
        }

        function drawCircle(center) {
            drawnItems.clearLayers();
            circleCenter = center;
            pentagonCenter = null;
            isPentagonActive = false;

            const rMeters = parseInt(document.getElementById('radiusInput').value);

            // Use Turf to create a proper circle polygon (for clipping compatibility)
            const circleGeoJSON = turf.circle([center.lng, center.lat], rMeters / 1000, { units: 'kilometers', steps: 64 });
            const coords = circleGeoJSON.geometry.coordinates[0].map(c => [c[1], c[0]]);

            const polygon = L.polygon(coords, { color: '#c026d3', weight: 3, fillOpacity: 0.1 });
            drawnItems.addLayer(polygon);
            selectedShapeLayer = polygon;
            selectedBounds = polygon.getBounds();

            isCircleActive = true;
            document.getElementById('zone-status').innerHTML = "‚¨§ Cercle Actif (" + (rMeters / 1000) + "km)";
            document.getElementById('zone-status').style.color = "#c026d3";
        }

        function updatePentagonTransform() {
            const r = document.getElementById('radiusInput').value;
            const rot = document.getElementById('rotInput').value;

            document.getElementById('radiusVal').textContent = (r / 1000).toFixed(1) + " km";
            document.getElementById('rotVal').textContent = rot + "¬∞";

            if (isPentagonActive && pentagonCenter) {
                drawPentagon(pentagonCenter);
            }
            if (isCircleActive && circleCenter) {
                drawCircle(circleCenter);
            }
        }


        // Events
        map.on(L.Draw.Event.CREATED, function (e) {
            drawnItems.clearLayers();
            drawnItems.addLayer(e.layer);
            selectedShapeLayer = e.layer;
            selectedBounds = e.layer.getBounds();
            isPentagonActive = false;
            isCircleActive = false;
            document.getElementById('zone-status').innerHTML = "‚úÖ Zone Valide (Manuel)";
            document.getElementById('zone-status').style.color = "green";
        });

        // V32: Click to place circle
        map.on('click', function (e) {
            if (isCircleActive && !circleCenter) {
                drawCircle(e.latlng);
            }
        });

        // --- MULTI-FILE EXPORT LOGIC (DESTRUCTIVE CLIP + BATCH + ALIGNMENT FRAME) ---

        async function downloadSelectedLayers() {
            if (map.getZoom() < 12) {
                if (!confirm("‚ö†Ô∏è ATTENTION : Zone tr√®s large.\nRisque de Timeout serveur.\nVoulez-vous continuer ?")) return;
            }

            // 1. Define Clipping Mask & Overpass Filter
            let maskPolygon = null;
            let overpassFilter = "";

            if (selectedShapeLayer && selectedShapeLayer instanceof L.Polygon) {
                const latlngs = selectedShapeLayer.getLatLngs()[0];
                const coords = latlngs.map(pt => [pt.lng, pt.lat]);
                if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {
                    coords.push(coords[0]);
                }
                maskPolygon = turf.polygon([coords]);

                const polyStr = latlngs.map(pt => `${pt.lat} ${pt.lng}`).join(" ");
                overpassFilter = `(poly:"${polyStr}")`;
            } else {
                const b = selectedBounds || map.getBounds();
                maskPolygon = turf.bboxPolygon([b.getWest(), b.getSouth(), b.getEast(), b.getNorth()]);
                overpassFilter = `(${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()})`;
            }

            const layers = [
                { id: 'chk_eau', type: 'eau', name: 'Eau', color: 'blue', fill: true },
                { id: 'chk_routes_locales', type: 'routes_locales', name: 'Rues', color: 'black', width: 1 },
                { id: 'chk_routes_secondaires', type: 'routes_secondaires', name: 'Routes_Principales', color: 'orange', width: 3 },
                { id: 'chk_routes_grands', type: 'routes_grands', name: 'Autoroutes', color: 'red', width: 5 },
                { id: 'chk_bati', type: 'bati', name: 'Batiments', color: 'black', fill: true }
            ];

            const activeLayers = layers.filter(l => document.getElementById(l.id).checked);
            const shouldMerge = document.getElementById('chk_merge').checked;

            // V21 Inputs
            const targetWidthCm = parseFloat(document.getElementById('exportWidth').value) || 10;
            const roadThickMm = parseFloat(document.getElementById('roadThick').value) || 4;
            const frameMarginMm = parseFloat(document.getElementById('frameMargin').value) || 5; // V30
            const renderStyle = document.getElementById('renderStyle').value; // 'fill' or 'stroke'
            const roadMode = document.getElementById('roadMode').value; // 'surface' or 'centerline' (V26)

            if (activeLayers.length === 0) {
                alert("Veuillez cocher au moins une couche !");
                return;
            }

            const status = document.getElementById("global-status");
            status.textContent = "D√©marrage V32...";

            // Prepare SVG Dimensions
            const bounds = selectedBounds || map.getBounds();
            const minLat = bounds.getSouth();
            const maxLat = bounds.getNorth();
            const minLon = bounds.getWest();
            const maxLon = bounds.getEast();

            // Calc Aspect Ratio & Height
            const widthGeo = turf.distance([minLon, (minLat + maxLat) / 2], [maxLon, (minLat + maxLat) / 2], { units: 'kilometers' });
            const heightGeo = turf.distance([(minLon + maxLon) / 2, minLat], [(minLon + maxLon) / 2, maxLat], { units: 'kilometers' });
            const aspectRatio = heightGeo / widthGeo;

            // SVG output Size
            const widthSvgPx = 1000;
            const heightSvgPx = 1000 * aspectRatio;
            const targetHeightCm = targetWidthCm * aspectRatio;

            // Base Scale Calc
            const metersPerCm = (widthGeo * 1000) / targetWidthCm;

            console.log(`V21: Width=${targetWidthCm}cm, RoadThick=${roadThickMm}mm. Scale: 1cm=${metersPerCm.toFixed(1)}m.`);

            function project(lat, lon) {
                const px = ((lon - minLon) / (maxLon - minLon)) * widthSvgPx;
                const py = heightSvgPx - ((lat - minLat) / (maxLat - minLat) * heightSvgPx); // fixed simplified projection
                return [px, py];
            }

            // Alignment Frame
            let framePathD = "";
            if (maskPolygon && maskPolygon.geometry && maskPolygon.geometry.coordinates) {
                const ring = maskPolygon.geometry.coordinates[0];
                ring.forEach((pt, i) => {
                    const [px, py] = project(pt[1], pt[0]);
                    framePathD += (i === 0 ? "M " : " L ") + px.toFixed(2) + " " + py.toFixed(2);
                });
                framePathD += " Z";
            }

            let errorCount = 0;
            const safeProjName = (document.getElementById('projectName').value || "Carte_Laser").replace(/[^a-z0-9]/gi, '_');
            const dateStr = new Date().toISOString().split('T')[0];

            // V32: Combine ALL road layers into one if in Surface mode
            const roadLayers = activeLayers.filter(l => l.type.startsWith('routes'));
            const nonRoadLayers = activeLayers.filter(l => !l.type.startsWith('routes'));

            if (roadLayers.length > 0 && roadMode === 'surface') {
                status.textContent = "V32: Fusion de toutes les routes...";

                // Build combined query for all selected road types
                let roadQueryParts = [];
                roadLayers.forEach(layer => {
                    if (layer.type === 'routes_grands') roadQueryParts.push(`way["highway"~"motorway|trunk|primary"]${overpassFilter}`);
                    else if (layer.type === 'routes_secondaires') roadQueryParts.push(`way["highway"~"secondary|tertiary"]${overpassFilter}`);
                    else if (layer.type === 'routes_locales') roadQueryParts.push(`way["highway"~"residential|unclassified|living_street|pedestrian"]${overpassFilter}`);
                });

                const combinedRoadQuery = `[out:json][timeout:600]; (${roadQueryParts.join('; ')}); out geom tags;`;

                try {
                    const resp = await fetch(`https://overpass.kumi.systems/api/interpreter?data=${encodeURIComponent(combinedRoadQuery)}`);
                    if (!resp.ok) throw new Error("Erreur HTTP " + resp.status);
                    const data = await resp.json();

                    status.textContent = `Routes combin√©es: ${data.elements ? data.elements.length : 0} segments...`;

                    // Use highest thickness (routes_grands multiplier = 1.0)
                    const combinedRadius = (roadThickMm / 10 / 2) * metersPerCm;

                    // Create a combined layer object
                    const combinedLayer = {
                        type: 'routes_combined',
                        name: 'Routes_Combin√©es',
                        color: 'black'
                    };

                    const groupContent = processLayerGeometry(data, combinedLayer, maskPolygon, project, metersPerPx(maxLat, minLat), true, true, combinedRadius, frameMarginMm, metersPerCm);

                    if (groupContent) {
                        let fillVal = "none";
                        let strokeVal = "red";
                        let strokeWidthVal = "0.5";

                        if (renderStyle === 'fill') {
                            fillVal = "black";
                            strokeVal = "none";
                            strokeWidthVal = "0";
                        }

                        const layerSVG = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="${targetWidthCm}cm" height="${targetHeightCm.toFixed(2)}cm" viewBox="0 0 ${widthSvgPx.toFixed(2)} ${heightSvgPx.toFixed(2)}">
  <g id="Routes_Combin√©es" stroke="${strokeVal}" fill="${fillVal}" stroke-width="${strokeWidthVal}" stroke-linecap="round" stroke-linejoin="round">
    ${groupContent}
  </g>
  <!-- Cadre d'Alignement -->
  <path d="${framePathD}" fill="none" stroke="red" stroke-width="0.5" vector-effect="non-scaling-stroke" id="frame_alignment" />
</svg>`;
                        const filename = `${safeProjName}_Routes_Combin√©es_V32_${dateStr}.svg`;
                        downloadStringAsFile(layerSVG, filename);
                        console.log('V32: Combined roads exported successfully.');
                    }
                } catch (e) {
                    console.error("V32 Combined roads failed", e);
                    errorCount++;
                }
            }

            // Process non-road layers (and roads in centerline mode) individually
            const layersToProcess = roadMode === 'surface' ? nonRoadLayers : activeLayers;

            for (const layer of layersToProcess) {
                status.textContent = "Traitement : " + layer.name + "...";

                let queryType = "";
                if (layer.type === 'routes_grands') queryType = `way["highway"~"motorway|trunk|primary"]`;
                else if (layer.type === 'routes_secondaires') queryType = `way["highway"~"secondary|tertiary"]`;
                else if (layer.type === 'routes_locales') queryType = `way["highway"~"residential|unclassified|living_street|pedestrian"]`;
                else if (layer.type === 'eau') queryType = `way["natural"="water"]; way["waterway"]`;
                else if (layer.type === 'bati') queryType = `way["building"]`;

                let queryBody = "";
                if (layer.type === 'eau') {
                    queryBody = `way["natural"="water"]${overpassFilter}; way["waterway"]${overpassFilter};`;
                } else {
                    queryBody = `${queryType}${overpassFilter};`;
                }

                const query = `[out:json][timeout:600]; (${queryBody}); out geom tags;`;

                try {
                    const resp = await fetch(`https://overpass.kumi.systems/api/interpreter?data=${encodeURIComponent(query)}`);
                    if (!resp.ok) throw new Error("Erreur HTTP " + resp.status);
                    const data = await resp.json();

                    status.textContent = `${layer.name}: ${data.elements ? data.elements.length : 0} objets...`;

                    // Determine radius based on layer hierarchy (V25)
                    let useBuffer = false;
                    let radius = 0;

                    if (layer.type.startsWith('routes')) {
                        // V26: Check Geometry Mode
                        if (roadMode === 'surface') {
                            useBuffer = true;
                            // Base Thickness
                            let multiplier = 1.0;
                            if (layer.type === 'routes_secondaires') multiplier = 0.7;
                            if (layer.type === 'routes_locales') multiplier = 0.4;

                            radius = ((roadThickMm / 10 / 2) * metersPerCm) * multiplier;
                        } else {
                            // Centerline Mode: No Buffer
                            useBuffer = false;
                            radius = 0;
                        }
                    }

                    // Generate Geometry
                    const groupContent = processLayerGeometry(data, layer, maskPolygon, project, metersPerPx(maxLat, minLat), shouldMerge, useBuffer, radius, frameMarginMm, metersPerCm);

                    if (groupContent) {
                        // V23: Style Logic
                        let fillVal = "none";
                        let strokeVal = "none";
                        let strokeWidthVal = "0";

                        // Is this layer a "Surface" (Filled)? 
                        // Water/Builds are filled. Roads are filled (buffered) in V21+.
                        const isSurface = (layer.fill || useBuffer);

                        if (renderStyle === 'fill') {
                            // MODE FILL: Black body, No stroke
                            if (isSurface) {
                                fillVal = layer.color;
                                strokeVal = "none";
                            } else {
                                // Fallback for pure lines (if any)
                                fillVal = "none";
                                strokeVal = layer.color;
                                strokeWidthVal = layer.width || 1;
                            }
                        } else {
                            // MODE STROKE (Outline/Cut): No Fill, Red Stroke
                            fillVal = "none";
                            // For cut, usually red, thin.
                            strokeVal = "red";
                            strokeWidthVal = "0.5"; // Thin line for laser vector
                        }

                        const layerSVG = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="${targetWidthCm}cm" height="${targetHeightCm.toFixed(2)}cm" viewBox="0 0 ${widthSvgPx.toFixed(2)} ${heightSvgPx.toFixed(2)}">
  <g id="${layer.name}" stroke="${strokeVal}" fill="${fillVal}" stroke-width="${strokeWidthVal}" stroke-linecap="round" stroke-linejoin="round">
    ${groupContent}
  </g>
  <!-- Cadre d'Alignement -->
  <path d="${framePathD}" fill="none" stroke="red" stroke-width="0.5" vector-effect="non-scaling-stroke" id="frame_alignment" />
</svg>`;
                        const filename = `${safeProjName}_${layer.name}_V32_${dateStr}.svg`;
                        downloadStringAsFile(layerSVG, filename);
                    } else {
                        console.warn("Aucune g√©om√©trie pour " + layer.name);
                    }

                } catch (e) {
                    console.error(e);
                    errorCount++;
                    status.textContent = "‚ùå Echec sur " + layer.name + " " + e.message;
                    await new Promise(r => setTimeout(r, 2000));
                }

                await new Promise(r => setTimeout(r, 1000));
            }

            if (errorCount > 0) alert("Attention : " + errorCount + " calque(s) ont √©chou√©.");
            status.textContent = errorCount === 0 ? "‚úÖ Export V32 Termin√© !" : "‚ö†Ô∏è Termin√© avec erreurs.";
        }

        function metersPerPx(maxLat, minLat) {
            return ((maxLat - minLat) * 111320) / 1000;
        }

        // --- GEOMETRY PROCESSOR (V30: Robustness + Difference) ---
        function processLayerGeometry(data, layer, maskPolygon, projectFn, mPerPx, shouldMerge, useBuffer, bufferRadius, frameMarginMm, metersPerCm) {
            if (!data.elements) return "";

            let parts = [];
            let compoundD = "";

            // 1. Convert to Turf Features / Buffer if needed
            let features = [];
            data.elements.forEach(el => {
                if (!el.geometry || el.geometry.length < 2) return;
                const coords = el.geometry.map(p => [p.lon, p.lat]);

                if (layer.fill || (layer.type === 'eau')) {
                    // WATER LOGIC (Keep V18)
                    const isLinearWater = (layer.type === 'eau' && (el.tags.waterway === 'river' || el.tags.waterway === 'canal' || el.tags.waterway === 'stream'));
                    if (isLinearWater) {
                        let pxWidth = 8;
                        if (el.tags.waterway === 'river') pxWidth = 25;
                        if (el.tags.waterway === 'canal') pxWidth = 15;
                        try {
                            const line = turf.lineString(coords);
                            const buf = turf.buffer(line, (pxWidth * mPerPx) / 2, { units: 'meters', steps: 12 });
                            features.push(buf);
                        } catch (e) { }
                    } else {
                        if (coords.length > 2) {
                            if (coords[0][0] !== coords[coords.length - 1][0]) coords.push(coords[0]);
                            try { features.push(turf.polygon([coords])); } catch (e) { }
                        }
                    }
                }
                else {
                    // ROADS LOGIC - V29: Collect lines first, buffer later
                    try {
                        const line = turf.lineString(coords);
                        const cleanLine = turf.cleanCoords(line);
                        features.push(cleanLine); // Just collect the line
                    } catch (e) { }
                }
            });

            // 2. ROADS: Merge lines first, then buffer the whole thing (V29)
            if (layer.type.startsWith('routes') && useBuffer && bufferRadius > 0 && features.length > 0) {
                try {
                    console.log(`V29: Processing ${features.length} road segments...`);

                    // Step 1: Combine all lines into a FeatureCollection
                    const lineCollection = turf.featureCollection(features);

                    // Step 2: Buffer the entire collection at once
                    // This creates a unified buffer with rounded caps that connect at intersections
                    const bufferedCollection = turf.buffer(lineCollection, bufferRadius, {
                        units: 'meters',
                        steps: 16  // Smooth rounded caps
                    });

                    // Step 3: Union all the buffered polygons into one
                    if (bufferedCollection && bufferedCollection.features && bufferedCollection.features.length > 0) {
                        console.log(`V29: Buffered into ${bufferedCollection.features.length} polygons, now unioning...`);

                        // Batch union for stability
                        const BATCH_SIZE = 50;
                        let processingQueue = bufferedCollection.features;

                        while (processingQueue.length > 1) {
                            let nextQueue = [];
                            for (let i = 0; i < processingQueue.length; i += BATCH_SIZE) {
                                const chunk = processingQueue.slice(i, i + BATCH_SIZE);
                                if (chunk.length === 1) {
                                    nextQueue.push(chunk[0]);
                                } else {
                                    let merged = chunk[0];
                                    for (let j = 1; j < chunk.length; j++) {
                                        try { merged = turf.union(merged, chunk[j]); } catch (e) { }
                                    }
                                    nextQueue.push(merged);
                                }
                            }
                            processingQueue = nextQueue;
                        }

                        if (processingQueue.length > 0) {
                            let roadSurface = turf.cleanCoords(processingQueue[0]);
                            roadSurface = turf.rewind(roadSurface);

                            // V30: Create outer frame and apply Difference
                            // Calculate frame margin in meters
                            const frameMarginMeters = (frameMarginMm / 10) * metersPerCm;

                            if (frameMarginMeters > 0) {
                                console.log(`V30: Creating outer frame with ${frameMarginMm}mm margin (${frameMarginMeters.toFixed(1)}m)...`);
                                try {
                                    // Create outer pentagon by buffering the mask
                                    const outerFrame = turf.buffer(maskPolygon, frameMarginMeters, {
                                        units: 'meters',
                                        steps: 16
                                    });

                                    // Apply Difference: OuterFrame - RoadSurface
                                    const result = turf.difference(outerFrame, roadSurface);

                                    if (result) {
                                        features = [result];
                                        console.log('V30: Difference operation successful.');
                                    } else {
                                        // Fallback to just the road surface if difference fails
                                        features = [roadSurface];
                                        console.warn('V30: Difference returned null, using road surface.');
                                    }
                                } catch (diffErr) {
                                    console.warn('V30: Difference failed', diffErr);
                                    features = [roadSurface];
                                }
                            } else {
                                // No frame margin, just use road surface
                                features = [roadSurface];
                            }

                            console.log('V30: Road processing complete.');
                        }
                    }
                } catch (e) {
                    console.warn("V30 Road processing failed", e);
                }
            }
            // 2b. WATER: Keep existing union logic
            else if (layer.type === 'eau' && features.length > 0) {
                try {
                    if (features.length > 4000) {
                        console.warn("Trop d'√©l√©ments pour Union (" + features.length + "). Skip Union.");
                    } else {
                        const BATCH_SIZE = 50;
                        let processingQueue = features;

                        while (processingQueue.length > 1) {
                            let nextQueue = [];
                            for (let i = 0; i < processingQueue.length; i += BATCH_SIZE) {
                                const chunk = processingQueue.slice(i, i + BATCH_SIZE);
                                if (chunk.length === 1) {
                                    nextQueue.push(chunk[0]);
                                } else {
                                    let merged = chunk[0];
                                    for (let j = 1; j < chunk.length; j++) {
                                        try { merged = turf.union(merged, chunk[j]); } catch (e) { }
                                    }
                                    nextQueue.push(merged);
                                }
                            }
                            processingQueue = nextQueue;
                        }

                        if (processingQueue.length > 0) {
                            let final = turf.cleanCoords(processingQueue[0]);
                            final = turf.rewind(final);
                            features = [final];
                        }
                    }
                } catch (e) { console.warn("Union failed", e); }
            }

            // 3. HARD CLIP (INTERSECTION)
            features.forEach(f => {
                if (!f) return;
                try {
                    let geometryToDraw = null;

                    // V24: Geometry Hygiene (Important for Polygons like Buildings)
                    f = turf.cleanCoords(f);
                    f = turf.rewind(f);

                    const type = f.geometry.type;

                    if (type === 'Polygon' || type === 'MultiPolygon') {
                        geometryToDraw = turf.intersect(f, maskPolygon);
                    }
                    else if (type === 'LineString') {
                        // (Only if not buffered)
                        if (turf.booleanWithin(f, maskPolygon)) {
                            geometryToDraw = f;
                        } else {
                            const split = turf.lineSplit(f, maskPolygon);
                            if (split.features.length > 0) {
                                split.features.forEach(seg => {
                                    if (turf.booleanPointInPolygon(turf.midpoint(seg), maskPolygon)) {
                                        processFeatureToPath(seg, projectFn, shouldMerge, parts, (d) => compoundD += d + " ");
                                    }
                                });
                                return;
                            } else if (turf.booleanIntersects(f, maskPolygon)) geometryToDraw = f;
                        }
                    }

                    // Safety Check: If intersect returned null/undefined, don't draw
                    if (geometryToDraw) {
                        processFeatureToPath(geometryToDraw, projectFn, shouldMerge, parts, (d) => compoundD += d + " ");
                    }
                } catch (e) {
                    // console.warn("Geo error", e);
                }
            });

            if (shouldMerge && compoundD.trim() !== "") {
                // If buffered (Fill), we don't need fill=none. Code handles type check.
                return `<path d="${compoundD}" vector-effect="non-scaling-stroke" />`;
            } else {
                return parts.join("\n");
            }
        }

        // Helper: Meters/Px
        function metersPerPx(maxLat, minLat) {
            return ((maxLat - minLat) * 111320) / 1000;
        }



        function processFeatureToPath(feature, projectFn, shouldMerge, partsList, onCompound) {
            turf.flatten(feature).features.forEach(f => {
                const coords = f.geometry.coordinates;
                const type = f.geometry.type;
                let d = "";

                if (type === 'Polygon') {
                    coords.forEach(ring => {
                        ring.forEach((pt, i) => {
                            const [px, py] = projectFn(pt[1], pt[0]);
                            d += (i === 0 ? "M " : " L ") + px.toFixed(2) + " " + py.toFixed(2);
                        });
                        d += " Z ";
                    });
                }
                else if (type === 'LineString') {
                    coords.forEach((pt, i) => {
                        const [px, py] = projectFn(pt[1], pt[0]);
                        d += (i === 0 ? "M " : " L ") + px.toFixed(2) + " " + py.toFixed(2);
                    });
                    // Lines don't close automatically
                }

                if (shouldMerge) {
                    onCompound(d);
                } else {
                    partsList.push(`<path d="${d}" fill="${type === 'Polygon' ? 'black' : 'none'}" vector-effect="non-scaling-stroke" />`);
                }
            });
        }

        function downloadStringAsFile(content, filename) {
            const blob = new Blob([content], { type: 'image/svg+xml' });
            const link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }
    </script>
</body>

</html>
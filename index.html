<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur Carte OSM (Vectoriel)</title>

    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Plugin Recherche (GeoSearch) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

    <!-- Leaflet Draw CSS & JS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

    <!-- Turf.js for Geometry -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

    <style>
        :root {
            --primary: #8b5cf6;
            --surface: #ffffff;
            --background: #f3f4f6;
            --text: #1f2937;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            height: 100vh;
            display: flex;
            background-color: var(--background);
            color: var(--text);
            overflow: hidden;
        }

        #sidebar {
            width: 380px;
            background-color: var(--surface);
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        h1 {
            font-size: 1.25rem;
            margin-top: 0;
            color: var(--primary);
            font-weight: 700;
        }

        .control-group {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e5e7eb;
        }

        .info {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 5px;
            line-height: 1.4;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            width: 100%;
            transition: background-color 0.2s;
            margin-bottom: 8px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
        }

        button:hover {
            background-color: #7c3aed;
        }

        button.secondary {
            background-color: #e5e7eb;
            color: #374151;
        }

        button.secondary:hover {
            background-color: #d1d5db;
        }

        /* Checkbox List Styles */
        .layer-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: #f9fafb;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .layer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
        }

        .layer-item:hover {
            background-color: #f3f4f6;
        }

        .layer-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .badge {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 10px;
            background: #e5e7eb;
            color: #4b5563;
            margin-left: auto;
        }

        #map {
            flex-grow: 1;
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        .leaflet-control-geocoder {
            z-index: 2000;
        }
    </style>
</head>

<body>

    <div id="sidebar">
        <h1>Carte Laser (OSM) V12 ‚¨†</h1>

        <!-- Nom du Projet -->
        <div style="margin-bottom: 20px;">
            <label style="font-size: 0.9rem; font-weight: 600;">Nom du Projet</label>
            <input type="text" id="projectName" placeholder="Ex: Paris 12e..."
                style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;">
        </div>

        <div class="control-group">
            <h3>1. Localisation</h3>
            <div class="info">Utilisez la loupe sur la carte pour chercher une ville.</div>
        </div>

        <div class="control-group">
            <h3>2. Zone de D√©coupe</h3>
            <div style="display: flex; gap: 10px; margin-bottom:10px;">
                <button onclick="initPentagon()" style="background-color: #d946ef;">
                    ‚¨† Pentagone
                </button>
                <button onclick="drawRectangle()" class="secondary">
                    ‚¨õ Carr√©
                </button>
            </div>

            <!-- Slider Taille -->
            <div style="margin-top: 5px;">
                <div style="display:flex; justify-content:space-between;">
                    <label style="font-size: 0.9rem; font-weight: 600;">Taille</label>
                    <span id="radiusVal" style="font-size: 0.8rem; color:#666;">2.0 km</span>
                </div>
                <input type="range" id="radiusInput" min="500" max="15000" step="100" value="2000"
                    style="width: 100%; accent-color: #d946ef;" oninput="updatePentagonTransform()">
            </div>

            <!-- Slider Rotation -->
            <div style="margin-top: 10px;">
                <div style="display:flex; justify-content:space-between;">
                    <label style="font-size: 0.9rem; font-weight: 600;">Rotation</label>
                    <span id="rotVal" style="font-size: 0.8rem; color:#666;">0¬∞</span>
                </div>
                <input type="range" id="rotInput" min="0" max="360" step="5" value="0"
                    style="width: 100%; accent-color: #d946ef;" oninput="updatePentagonTransform()">
            </div>

            <div id="zone-status" class="info" style="color: red;">Aucune zone dessin√©e.</div>
        </div>

        <div class="control-group">
            <h3>3. S√©lectionner les Couches</h3>
            <div class="info" style="margin-bottom:10px;">
                Cochez les √©l√©ments √† inclure dans le t√©l√©chargement.
            </div>

            <div class="layer-list">
                <label class="layer-item">
                    <input type="checkbox" id="chk_routes_grands" checked>
                    <span>üõ£Ô∏è Autoroutes & Nationales</span>
                    <span class="badge">√âpais</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_routes_secondaires" checked>
                    <span>üöó Routes Principales</span>
                    <span class="badge">Moyen</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_routes_locales" checked>
                    <span>üèòÔ∏è Rues Locales</span>
                    <span class="badge">Fin</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_eau" checked>
                    <span>üíß Fleuves & Lacs</span>
                    <span class="badge">Rempli</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_bati">
                    <span>üè¢ B√¢timents</span>
                    <span class="badge">Lourd</span>
                </label>
            </div>

            <br>
            <button onclick="downloadSelectedLayers()" style="font-size: 1.1rem; padding: 15px;">
                ‚¨áÔ∏è T√âL√âCHARGER LA S√âLECTION
            </button>

            <div id="global-status" class="info" style="font-weight: bold; color: var(--primary); margin-top:10px;">
            </div>
        </div>

        <div class="control-group">
            <h3>4. Rendu Visuel</h3>
            <div style="display:flex; gap:10px">
                <button class="secondary" onclick="setLayer('light')">Blanc</button>
                <button class="secondary" onclick="setLayer('dark')">Noir</button>
            </div>
        </div>

    </div>

    <div id="map"></div>

    <script>
        // Init Map
        const map = L.map('map').setView([48.8566, 2.3522], 13);

        // Layers
        const layers = {
            osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM' }),
            light: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; CartoDB' }),
            dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; CartoDB' })
        };
        layers.light.addTo(map);

        function setLayer(name) {
            map.eachLayer(layer => {
                if (layer._url) map.removeLayer(layer);
            });
            layers[name].addTo(map);
        }

        // Search
        L.Control.geocoder({ defaultMarkGeocode: false })
            .on('markgeocode', function (e) {
                const bbox = e.geocode.bbox;
                const poly = L.polygon([bbox.getSouthEast(), bbox.getNorthEast(), bbox.getNorthWest(), bbox.getSouthWest()]);
                map.fitBounds(poly.getBounds());
            })
            .addTo(map);

        // --- DRAW FEATURE ---
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        let selectedBounds = null;
        let selectedShapeLayer = null;
        let isPentagonActive = false;
        let pentagonCenter = null;

        function drawRectangle() {
            isPentagonActive = false;
            pentagonCenter = null;
            new L.Draw.Rectangle(map, { shapeOptions: { color: '#2563eb' } }).enable();
        }

        function updatePentagonTransform() {
            const r = document.getElementById('radiusInput').value;
            const rot = document.getElementById('rotInput').value;

            document.getElementById('radiusVal').textContent = (r / 1000).toFixed(1) + " km";
            document.getElementById('rotVal').textContent = rot + "¬∞";

            if (isPentagonActive && pentagonCenter) {
                drawPentagon(pentagonCenter);
            }
        }

        function initPentagon() {
            const center = map.getCenter();
            drawPentagon(center);
        }

        // --- PENTAGON LOGIC (RESIZABLE + ROTATABLE) ---
        function drawPentagon(center) {
            drawnItems.clearLayers();
            pentagonCenter = center;

            // Radius from slider
            const rMeters = parseInt(document.getElementById('radiusInput').value);
            const radiusDeg = rMeters / 111320;

            // Rotation from slider (deg -> rad)
            const rotDeg = parseInt(document.getElementById('rotInput').value);
            const rotRad = rotDeg * (Math.PI / 180);

            const points = [];
            const sides = 5;
            const baseRot = -Math.PI / 2; // Point up default

            for (let i = 0; i < sides; i++) {
                const angle = (i * 2 * Math.PI) / sides + baseRot + rotRad;
                const latOffset = radiusDeg * Math.sin(angle);
                const lonOffset = (radiusDeg * Math.cos(angle)) / Math.cos(center.lat * Math.PI / 180);

                points.push([center.lat + latOffset, center.lng + lonOffset]);
            }
            const polygon = L.polygon(points, { color: '#d946ef', weight: 3 });
            drawnItems.addLayer(polygon);
            selectedShapeLayer = polygon;
            selectedBounds = polygon.getBounds();

            isPentagonActive = true;
            document.getElementById('zone-status').innerHTML = "‚¨† Pentagone Actif (" + (rMeters / 1000) + "km)";
            document.getElementById('zone-status').style.color = "#d946ef";
        }

        // Events
        map.on(L.Draw.Event.CREATED, function (e) {
            drawnItems.clearLayers();
            drawnItems.addLayer(e.layer);
            selectedShapeLayer = e.layer;
            selectedBounds = e.layer.getBounds();
            isPentagonActive = false;
            document.getElementById('zone-status').innerHTML = "‚úÖ Zone Valide (Manuel)";
            document.getElementById('zone-status').style.color = "green";
        });


        // --- BATCH DOWNLOAD LOGIC ---

        async function downloadSelectedLayers() {
            if (map.getZoom() < 12) {
                if (!confirm("‚ö†Ô∏è ATTENTION : Vous √™tes tr√®s d√©zoom√©.\nLa zone demand√©e est gigantesque.\n\nLe serveur risque de planter (Erreur 504 Timeout).\n\nConseil : Zoomez plus pr√®s ou r√©duisez la zone.\nVoulez-vous quand m√™me tenter ?")) return;
            }

            const layers = [
                { id: 'chk_routes_grands', type: 'routes_grands' },
                { id: 'chk_routes_secondaires', type: 'routes_secondaires' },
                { id: 'chk_routes_locales', type: 'routes_locales' },
                { id: 'chk_eau', type: 'eau' },
                { id: 'chk_bati', type: 'bati' }
            ];

            const activeLayers = layers.filter(l => document.getElementById(l.id).checked);

            if (activeLayers.length === 0) {
                alert("Veuillez cocher au moins une couche !");
                return;
            }

            const status = document.getElementById("global-status");
            status.textContent = "D√©marrage des exports...";

            for (const layer of activeLayers) {
                status.textContent = "T√©l√©chargement : " + layer.type + "...";
                await downloadSVG(layer.type);
                await new Promise(r => setTimeout(r, 1500));
            }

            status.textContent = "‚úÖ Tous les fichiers sont pr√™ts !";
        }

        // --- CORE SVG LOGIC ---

        async function downloadSVG(type) {
            let bounds = selectedBounds;
            if (!bounds) {
                if (!confirm("Pas de zone. Tout l'√©cran ?")) return;
                bounds = map.getBounds();
            }

            const s = bounds.getSouth();
            const w = bounds.getWest();
            const n = bounds.getNorth();
            const e = bounds.getEast();

            let queryFilter = "";
            let niceName = type;

            if (type === 'routes_grands') {
                queryFilter = `way["highway"~"motorway|trunk|primary"](${s},${w},${n},${e});`;
                niceName = "Autoroutes";
            }
            else if (type === 'routes_secondaires') {
                queryFilter = `way["highway"~"secondary|tertiary"](${s},${w},${n},${e});`;
                niceName = "Routes_Principales";
            }
            else if (type === 'routes_locales') {
                queryFilter = `way["highway"~"residential|unclassified|living_street"](${s},${w},${n},${e});`;
                niceName = "Rues";
            }
            else if (type === 'eau') {
                queryFilter = `way["natural"="water"](${s},${w},${n},${e}); way["waterway"](${s},${w},${n},${e});`;
                niceName = "Eau";
            }
            else if (type === 'bati') {
                queryFilter = `way["building"](${s},${w},${n},${e});`;
                niceName = "Batiments";
            }

            // Construct Filename
            const rawProjectName = document.getElementById('projectName').value.trim();
            const safeProjectName = rawProjectName ? rawProjectName.replace(/[^a-z0-9]/gi, '_') : "Carte_Laser";
            const dateStr = new Date().toISOString().split('T')[0];
            const filename = `${safeProjectName}_${niceName}_${dateStr}.svg`;

            const query = `[out:json][timeout:300]; (${queryFilter}); out geom tags;`;
            const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error("Erreur API " + response.status);
                const data = await response.json();
                const svgContent = generateSVGFromJSON(data, bounds, type);

                if (svgContent) downloadStringAsFile(svgContent, filename);
            } catch (err) {
                console.error(err);
                const status = document.getElementById("global-status");
                status.textContent = "‚ùå Erreur " + type + " (Timeout/Trop grand)";
            }
        }

        function generateSVGFromJSON(data, bounds, layerType) {
            if (!data.elements || data.elements.length === 0) return null;

            const minLat = bounds.getSouth();
            const maxLat = bounds.getNorth();
            const minLon = bounds.getWest();
            const maxLon = bounds.getEast();

            // Projection Setup
            const midLat = (minLat + maxLat) / 2;
            const cosLat = Math.cos(midLat * Math.PI / 180);
            const widthSvg = 1000 * ((maxLon - minLon) / (maxLat - minLat)) * cosLat;
            const heightSvg = 1000;

            // Helper: LatLon -> SVG px
            function project(lat, lon) {
                const px = ((lon - minLon) / (maxLon - minLon)) * widthSvg;
                const py = 1000 - ((lat - minLat) / (maxLat - minLat) * 1000);
                return [px, py];
            }

            // Clip Path Logic
            let clipPathD = "";
            if (selectedShapeLayer && selectedShapeLayer instanceof L.Polygon) {
                const latlngs = selectedShapeLayer.getLatLngs()[0];
                latlngs.forEach((pt, i) => {
                    const [px, py] = project(pt.lat, pt.lng);
                    clipPathD += (i === 0 ? "M " : " L ") + px.toFixed(2) + " " + py.toFixed(2);
                });
                clipPathD += " Z";
            } else {
                clipPathD = `M 0 0 L ${widthSvg} 0 L ${widthSvg} 1000 L 0 1000 Z`;
            }

            // --- TURF.JS GEOMETRY PROCESSING (For Water) ---

            let paths = [];

            if (layerType === 'eau') {
                // Collect GeoJSON Features
                let featuresToUnion = [];

                // Calculate approx meters per pixel for buffer
                // Earth circum = 40075km. 1 deg lat = 111km.
                // Height in degrees = maxLat - minLat.
                // Height in meters = (maxLat - minLat) * 111320.
                // SVG Height = 1000px.
                // Meters per px = HeightM / 1000.
                const metersPerPx = ((maxLat - minLat) * 111320) / 1000;

                data.elements.forEach(el => {
                    if (!el.geometry || el.geometry.length < 2) return;

                    const isArea = (el.tags.natural === 'water' || el.tags.waterway === 'riverbank' || el.tags.landuse === 'reservoir');
                    const isLinear = (el.tags.waterway === 'river' || el.tags.waterway === 'canal' || el.tags.waterway === 'stream');

                    // Convert OSM geometry to Coordinates [[lon, lat], ...]
                    const coords = el.geometry.map(pt => [pt.lon, pt.lat]);

                    if (isArea) {
                        // Close polygon if needed
                        if (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1]) {
                            coords.push(coords[0]);
                        }
                        // Add to collection
                        try {
                            featuresToUnion.push(turf.polygon([coords]));
                        } catch (e) { /* Invalid geometry */ }
                    }
                    else if (isLinear) {
                        // Buffer Width (Pixels -> Meters)
                        let pxWidth = 8;
                        if (el.tags.waterway === 'river') pxWidth = 25;
                        if (el.tags.waterway === 'canal') pxWidth = 15;

                        const bufferDist = (pxWidth * metersPerPx) / 2; // Radius

                        try {
                            const line = turf.lineString(coords);
                            const buffered = turf.buffer(line, bufferDist, { units: 'meters' });
                            featuresToUnion.push(buffered);
                        } catch (e) { }
                    }
                });

                // UNION EVERYTHING
                if (featuresToUnion.length > 0) {
                    let merged = featuresToUnion[0];
                    for (let i = 1; i < featuresToUnion.length; i++) {
                        try {
                            merged = turf.union(merged, featuresToUnion[i]);
                        } catch (e) { /* Ignore merge fail */ }
                    }

                    // DRAW RESULT
                    // Merged can be Polygon or MultiPolygon
                    const geoms = (merged.geometry.type === 'Polygon') ? [merged.geometry.coordinates] : merged.geometry.coordinates;

                    geoms.forEach(polyCoords => {
                        // Polygon has [OuterRing, Hole1, Hole2...]
                        polyCoords.forEach(ring => {
                            let d = "";
                            ring.forEach((pt, i) => {
                                const [px, py] = project(pt[1], pt[0]); // GeoJSON is Lon,Lat. Project wants Lat,Lon
                                d += (i === 0 ? "M " : " L ") + px.toFixed(2) + " " + py.toFixed(2);
                            });
                            d += " Z";
                            paths.push(`<path d="${d}" fill="black" stroke="none" />`);
                        });
                    });
                }

            } else {
                // --- STANDARD LOGIC FOR ROADS (NON-MERGED) ---
                data.elements.forEach(el => {
                    if (!el.geometry || el.geometry.length < 2) return;

                    let strokeWidth = 1;
                    if (layerType === 'routes_grands') strokeWidth = 5;
                    else if (layerType === 'routes_secondaires') strokeWidth = 3;
                    else if (layerType === 'bati') {
                        // Buildings are shapes
                        let d = "";
                        el.geometry.forEach((pt, i) => {
                            const [px, py] = project(pt.lat, pt.lon);
                            d += (i === 0 ? "M " : " L ") + px.toFixed(2) + " " + py.toFixed(2);
                        });
                        // Close loop for buildings
                        d += " Z";
                        paths.push(`<path d="${d}" fill="black" stroke="none" />`);
                        return; // Skip the line drawing below
                    }

                    // Project
                    let d = "";
                    el.geometry.forEach((pt, i) => {
                        const [px, py] = project(pt.lat, pt.lon);
                        d += (i === 0 ? "M " : " L ") + px.toFixed(2) + " " + py.toFixed(2);
                    });

                    paths.push(`<path d="${d}" fill="none" stroke="black" stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round" />`);
                });
            }

            if (paths.length === 0) return null;

            return `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ${widthSvg.toFixed(2)} ${heightSvg}">
  <defs><clipPath id="shapeClip"><path d="${clipPathD}"/></clipPath></defs>
  <g id="layer_${layerType}" clip-path="url(#shapeClip)">
    ${paths.join("\n    ")}
  </g>
  <path d="${clipPathD}" fill="none" stroke="red" stroke-width="2" id="cut_line" />
</svg>`;
        }

        function downloadStringAsFile(content, filename) {
            const blob = new Blob([content], { type: 'image/svg+xml' });
            const link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }
    </script>
</body>

</html>
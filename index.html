<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur Carte OSM (Vectoriel)</title>

    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Plugin Recherche (GeoSearch) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

    <!-- Leaflet Draw CSS & JS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

    <!-- Turf.js for Geometry -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

    <style>
        :root {
            --primary: #8b5cf6;
            --surface: #ffffff;
            --background: #f3f4f6;
            --text: #1f2937;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            height: 100vh;
            display: flex;
            background-color: var(--background);
            color: var(--text);
            overflow: hidden;
        }

        #sidebar {
            width: 380px;
            background-color: var(--surface);
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        h1 {
            font-size: 1.25rem;
            margin-top: 0;
            color: var(--primary);
            font-weight: 700;
        }

        .control-group {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e5e7eb;
        }

        .info {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 5px;
            line-height: 1.4;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            width: 100%;
            transition: background-color 0.2s;
            margin-bottom: 8px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
        }

        button:hover {
            background-color: #7c3aed;
        }

        button.secondary {
            background-color: #e5e7eb;
            color: #374151;
        }

        button.secondary:hover {
            background-color: #d1d5db;
        }

        /* Checkbox List Styles */
        .layer-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: #f9fafb;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .layer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
        }

        .layer-item:hover {
            background-color: #f3f4f6;
        }

        .layer-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .badge {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 10px;
            background: #e5e7eb;
            color: #4b5563;
            margin-left: auto;
        }

        #map {
            flex-grow: 1;
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        .leaflet-control-geocoder {
            z-index: 2000;
        }
    </style>
</head>

<body>

    <div id="sidebar">
        <h1>Carte Laser (OSM) V23 ‚¨†</h1>
        <div style="text-align:center; font-size:0.8rem; opacity:0.7; margin-bottom:10px;">Version : V23 (Style
            D√©coupe/Gravure)</div>

        <!-- Nom du Projet -->
        <div style="margin-bottom: 20px;">
            <label style="font-size: 0.9rem; font-weight: 600;">Nom du Projet</label>
            <input type="text" id="projectName" placeholder="Ex: Paris 12e..."
                style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;">
        </div>

        <div class="control-group">
            <h3>1. Localisation</h3>
            <div class="info">Utilisez la loupe sur la carte pour chercher une ville.</div>
        </div>

        <div class="control-group">
            <h3>2. Zone de D√©coupe</h3>
            <div style="display: flex; gap: 10px; margin-bottom:10px;">
                <button onclick="initPentagon()" style="background-color: #d946ef;">
                    ‚¨† Pentagone
                </button>
                <button onclick="drawRectangle()" class="secondary">
                    ‚¨õ Carr√©
                </button>
            </div>

            <!-- Slider Taille -->
            <div style="margin-top: 5px;">
                <div style="display:flex; justify-content:space-between;">
                    <label style="font-size: 0.9rem; font-weight: 600;">Taille</label>
                    <span id="radiusVal" style="font-size: 0.8rem; color:#666;">2.0 km</span>
                </div>
                <input type="range" id="radiusInput" min="500" max="15000" step="100" value="2000"
                    style="width: 100%; accent-color: #d946ef;" oninput="updatePentagonTransform()">
            </div>

            <!-- Slider Rotation -->
            <div style="margin-top: 10px;">
                <div style="display:flex; justify-content:space-between;">
                    <label style="font-size: 0.9rem; font-weight: 600;">Rotation</label>
                    <span id="rotVal" style="font-size: 0.8rem; color:#666;">0¬∞</span>
                </div>
                <input type="range" id="rotInput" min="0" max="360" step="5" value="0"
                    style="width: 100%; accent-color: #d946ef;" oninput="updatePentagonTransform()">
            </div>

            <div id="zone-status" class="info" style="color: red;">Aucune zone dessin√©e.</div>
        </div>

        <div class="control-group">
            <h3>3. S√©lectionner les Couches</h3>
            <div class="info" style="margin-bottom:10px;">
                Cochez les √©l√©ments √† inclure dans le t√©l√©chargement.
            </div>

            <div class="layer-list">
                <label class="layer-item">
                    <input type="checkbox" id="chk_routes_grands" checked>
                    <span>üõ£Ô∏è Autoroutes & Nationales</span>
                    <span class="badge">√âpais</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_routes_secondaires" checked>
                    <span>üöó Routes Principales</span>
                    <span class="badge">Moyen</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_routes_locales" checked>
                    <span>üèòÔ∏è Rues Locales</span>
                    <span class="badge">Fin</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_eau" checked>
                    <span>üíß Fleuves & Lacs</span>
                    <span class="badge">Rempli</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_bati" checked>
                    <span>üè¢ B√¢timents</span>
                    <span class="badge">Lourd</span>
                </label>
            </div>

            <!-- Options Export -->
            <div style="margin-top:20px; border-top:1px solid #ddd; padding-top:10px;">
                <label style="font-size:0.9rem; display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="chk_merge" checked style="accent-color:#d946ef; margin-right:8px;">
                    Fusionner les trac√©s (1 objet/calque)
                </label>

                <!-- V21: Dimensions Physiques -->
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px;">
                    <div>
                        <label style="font-size:0.8rem; font-weight:600;">Largeur (cm)</label>
                        <input type="number" id="exportWidth" value="10" min="1" max="100"
                            style="width:100%; padding:4px;">
                    </div>
                    <div>
                        <label style="font-size:0.8rem; font-weight:600;">√âpaisseur (mm)</label>
                        <input type="number" id="roadThick" value="4" min="0.1" max="20" step="0.1"
                            style="width:100%; padding:4px;">
                    </div>
                </div>

                <!-- V23: Style export -->
                <div style="margin-top:10px;">
                    <label style="font-size:0.8rem; font-weight:600;">Style de Rendu</label>
                    <select id="renderStyle" style="width:100%; padding:4px; margin-top:4px;">
                        <option value="fill">‚¨õ Remplissage (Surface/Gravure)</option>
                        <option value="stroke">‚≠ï Contour (D√©coupe Vectorielle)</option>
                    </select>
                </div>
            </div>

            <button onclick="downloadSelectedLayers()"
                style="width: 100%; margin-top: 20px; padding: 12px; background: #d946ef; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                T√©l√©charger SVG (Batch)
            </button>

            <div id="global-status" class="info" style="font-weight: bold; color: var(--primary); margin-top:10px;">
            </div>
        </div>

        <div class="control-group">
            <h3>4. Rendu Visuel</h3>
            <div style="display:flex; gap:10px">
                <button class="secondary" onclick="setLayer('light')">Blanc</button>
                <button class="secondary" onclick="setLayer('dark')">Noir</button>
            </div>
        </div>

    </div>

    <div id="map"></div>

    <script>
        // Init Map
        const map = L.map('map').setView([48.8566, 2.3522], 13);

        // Layers
        const layers = {
            osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM' }),
            light: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; CartoDB' }),
            dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; CartoDB' })
        };
        layers.light.addTo(map);

        function setLayer(name) {
            map.eachLayer(layer => {
                if (layer._url) map.removeLayer(layer);
            });
            layers[name].addTo(map);
        }

        // Search
        L.Control.geocoder({ defaultMarkGeocode: false })
            .on('markgeocode', function (e) {
                const bbox = e.geocode.bbox;
                const poly = L.polygon([bbox.getSouthEast(), bbox.getNorthEast(), bbox.getNorthWest(), bbox.getSouthWest()]);
                map.fitBounds(poly.getBounds());
            })
            .addTo(map);

        // --- DRAW FEATURE ---
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        let selectedBounds = null;
        let selectedShapeLayer = null;
        let isPentagonActive = false;
        let pentagonCenter = null;

        function drawRectangle() {
            isPentagonActive = false;
            pentagonCenter = null;
            new L.Draw.Rectangle(map, { shapeOptions: { color: '#2563eb' } }).enable();
        }

        function updatePentagonTransform() {
            const r = document.getElementById('radiusInput').value;
            const rot = document.getElementById('rotInput').value;

            document.getElementById('radiusVal').textContent = (r / 1000).toFixed(1) + " km";
            document.getElementById('rotVal').textContent = rot + "¬∞";

            if (isPentagonActive && pentagonCenter) {
                drawPentagon(pentagonCenter);
            }
        }

        function initPentagon() {
            const center = map.getCenter();
            drawPentagon(center);
        }

        // --- PENTAGON LOGIC (RESIZABLE + ROTATABLE) ---
        function drawPentagon(center) {
            drawnItems.clearLayers();
            pentagonCenter = center;

            // Radius from slider
            const rMeters = parseInt(document.getElementById('radiusInput').value);
            const radiusDeg = rMeters / 111320;

            // Rotation from slider (deg -> rad)
            const rotDeg = parseInt(document.getElementById('rotInput').value);
            const rotRad = rotDeg * (Math.PI / 180);

            const points = [];
            const sides = 5;
            const baseRot = -Math.PI / 2; // Point up default

            for (let i = 0; i < sides; i++) {
                const angle = (i * 2 * Math.PI) / sides + baseRot + rotRad;
                const latOffset = radiusDeg * Math.sin(angle);
                const lonOffset = (radiusDeg * Math.cos(angle)) / Math.cos(center.lat * Math.PI / 180);

                points.push([center.lat + latOffset, center.lng + lonOffset]);
            }
            const polygon = L.polygon(points, { color: '#d946ef', weight: 3 });
            drawnItems.addLayer(polygon);
            selectedShapeLayer = polygon;
            selectedBounds = polygon.getBounds();

            isPentagonActive = true;
            document.getElementById('zone-status').innerHTML = "‚¨† Pentagone Actif (" + (rMeters / 1000) + "km)";
            document.getElementById('zone-status').style.color = "#d946ef";
        }

        // Events
        map.on(L.Draw.Event.CREATED, function (e) {
            drawnItems.clearLayers();
            drawnItems.addLayer(e.layer);
            selectedShapeLayer = e.layer;
            selectedBounds = e.layer.getBounds();
            isPentagonActive = false;
            document.getElementById('zone-status').innerHTML = "‚úÖ Zone Valide (Manuel)";
            document.getElementById('zone-status').style.color = "green";
        });


        // --- MULTI-FILE EXPORT LOGIC (DESTRUCTIVE CLIP + BATCH + ALIGNMENT FRAME) ---

        async function downloadSelectedLayers() {
            if (map.getZoom() < 12) {
                if (!confirm("‚ö†Ô∏è ATTENTION : Zone tr√®s large.\nRisque de Timeout serveur.\nVoulez-vous continuer ?")) return;
            }

            // 1. Define Clipping Mask & Overpass Filter
            let maskPolygon = null;
            let overpassFilter = "";

            if (selectedShapeLayer && selectedShapeLayer instanceof L.Polygon) {
                const latlngs = selectedShapeLayer.getLatLngs()[0];
                const coords = latlngs.map(pt => [pt.lng, pt.lat]);
                if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {
                    coords.push(coords[0]);
                }
                maskPolygon = turf.polygon([coords]);

                const polyStr = latlngs.map(pt => `${pt.lat} ${pt.lng}`).join(" ");
                overpassFilter = `(poly:"${polyStr}")`;
            } else {
                const b = selectedBounds || map.getBounds();
                maskPolygon = turf.bboxPolygon([b.getWest(), b.getSouth(), b.getEast(), b.getNorth()]);
                overpassFilter = `(${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()})`;
            }

            const layers = [
                { id: 'chk_eau', type: 'eau', name: 'Eau', color: 'blue', fill: true },
                { id: 'chk_routes_locales', type: 'routes_locales', name: 'Rues', color: 'black', width: 1 },
                { id: 'chk_routes_secondaires', type: 'routes_secondaires', name: 'Routes_Principales', color: 'orange', width: 3 },
                { id: 'chk_routes_grands', type: 'routes_grands', name: 'Autoroutes', color: 'red', width: 5 },
                { id: 'chk_bati', type: 'bati', name: 'Batiments', color: 'black', fill: true }
            ];

            const activeLayers = layers.filter(l => document.getElementById(l.id).checked);
            const shouldMerge = document.getElementById('chk_merge').checked;

            // V21 Inputs
            const targetWidthCm = parseFloat(document.getElementById('exportWidth').value) || 10;
            const roadThickMm = parseFloat(document.getElementById('roadThick').value) || 4;
            const renderStyle = document.getElementById('renderStyle').value; // 'fill' or 'stroke'

            if (activeLayers.length === 0) {
                alert("Veuillez cocher au moins une couche !");
                return;
            }

            const status = document.getElementById("global-status");
            status.textContent = "D√©marrage V23...";

            // Prepare SVG Dimensions
            const bounds = selectedBounds || map.getBounds();
            const minLat = bounds.getSouth();
            const maxLat = bounds.getNorth();
            const minLon = bounds.getWest();
            const maxLon = bounds.getEast();

            // Calc Aspect Ratio & Height
            const widthGeo = turf.distance([minLon, (minLat + maxLat) / 2], [maxLon, (minLat + maxLat) / 2], { units: 'kilometers' });
            const heightGeo = turf.distance([(minLon + maxLon) / 2, minLat], [(minLon + maxLon) / 2, maxLat], { units: 'kilometers' });
            const aspectRatio = heightGeo / widthGeo;

            // SVG output Size
            const widthSvgPx = 1000;
            const heightSvgPx = 1000 * aspectRatio;
            const targetHeightCm = targetWidthCm * aspectRatio;

            // Calc Buffer for Roads (Physical -> Geo Meters)
            // Real Width in Meters = widthGeo * 1000
            // Scale (Meters per CM) = (widthGeo * 1000) / targetWidthCm
            // Desired Buffer Radius (Meters) = (roadThickMm / 10 / 2) * (Meters per CM) 
            // Wait. Convert mm to cm: roadThickMm/10. Divide by 2 for radius.
            // (0.4 cm / 2) = 0.2 cm radius.
            // 0.2 cm * Meters_Per_CM = Meters.
            const metersPerCm = (widthGeo * 1000) / targetWidthCm;
            const roadBufferMeters = (roadThickMm / 10 / 2) * metersPerCm;

            console.log(`V21: Width=${targetWidthCm}cm, RoadThick=${roadThickMm}mm. Scale: 1cm=${metersPerCm.toFixed(1)}m. Buffer=${roadBufferMeters.toFixed(1)}m`);

            function project(lat, lon) {
                const px = ((lon - minLon) / (maxLon - minLon)) * widthSvgPx;
                const py = heightSvgPx - ((lat - minLat) / (maxLat - minLat) * heightSvgPx); // fixed simplified projection
                return [px, py];
            }

            // Alignment Frame
            let framePathD = "";
            if (maskPolygon && maskPolygon.geometry && maskPolygon.geometry.coordinates) {
                const ring = maskPolygon.geometry.coordinates[0];
                ring.forEach((pt, i) => {
                    const [px, py] = project(pt[1], pt[0]);
                    framePathD += (i === 0 ? "M " : " L ") + px.toFixed(2) + " " + py.toFixed(2);
                });
                framePathD += " Z";
            }

            let errorCount = 0;
            const safeProjName = (document.getElementById('projectName').value || "Carte_Laser").replace(/[^a-z0-9]/gi, '_');
            const dateStr = new Date().toISOString().split('T')[0];

            for (const layer of activeLayers) {
                status.textContent = "Traitement : " + layer.name + "...";

                let queryType = "";
                if (layer.type === 'routes_grands') queryType = `way["highway"~"motorway|trunk|primary"]`;
                else if (layer.type === 'routes_secondaires') queryType = `way["highway"~"secondary|tertiary"]`;
                else if (layer.type === 'routes_locales') queryType = `way["highway"~"residential|unclassified|living_street"]`;
                else if (layer.type === 'eau') queryType = `way["natural"="water"]; way["waterway"]`;
                else if (layer.type === 'bati') queryType = `way["building"]`;

                let queryBody = "";
                if (layer.type === 'eau') {
                    queryBody = `way["natural"="water"]${overpassFilter}; way["waterway"]${overpassFilter};`;
                } else {
                    queryBody = `${queryType}${overpassFilter};`;
                }

                const query = `[out:json][timeout:600]; (${queryBody}); out geom tags;`;

                try {
                    const resp = await fetch(`https://overpass.kumi.systems/api/interpreter?data=${encodeURIComponent(query)}`);
                    if (!resp.ok) throw new Error("Erreur HTTP " + resp.status);
                    const data = await resp.json();

                    status.textContent = `${layer.name}: ${data.elements ? data.elements.length : 0} objets...`;

                    // Determine if road buffering applies
                    let useBuffer = false;
                    let radius = 0;
                    if (layer.type.startsWith('routes')) {
                        useBuffer = true;
                        radius = roadBufferMeters;
                    }
                    // Reuse water buffer logic separately if needed, but water code handles itself.

                    // Generate Geometry
                    const groupContent = processLayerGeometry(data, layer, maskPolygon, project, metersPerPx(maxLat, minLat), shouldMerge, useBuffer, radius);

                    if (groupContent) {
                        // V23: Style Logic
                        let fillVal = "none";
                        let strokeVal = "none";
                        let strokeWidthVal = "0";

                        // Is this layer a "Surface" (Filled)? 
                        // Water/Builds are filled. Roads are filled (buffered) in V21+.
                        const isSurface = (layer.fill || useBuffer);

                        if (renderStyle === 'fill') {
                            // MODE FILL: Black body, No stroke
                            if (isSurface) {
                                fillVal = layer.color;
                                strokeVal = "none";
                            } else {
                                // Fallback for pure lines (if any)
                                fillVal = "none";
                                strokeVal = layer.color;
                                strokeWidthVal = layer.width || 1;
                            }
                        } else {
                            // MODE STROKE (Outline/Cut): No Fill, Red Stroke
                            fillVal = "none";
                            // For cut, usually red, thin.
                            strokeVal = "red";
                            strokeWidthVal = "0.5"; // Thin line for laser vector
                        }

                        const layerSVG = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="${targetWidthCm}cm" height="${targetHeightCm.toFixed(2)}cm" viewBox="0 0 ${widthSvgPx.toFixed(2)} ${heightSvgPx.toFixed(2)}">
  <g id="${layer.name}" stroke="${strokeVal}" fill="${fillVal}" stroke-width="${strokeWidthVal}">
    ${groupContent}
  </g>
  <!-- Cadre d'Alignement -->
  <path d="${framePathD}" fill="none" stroke="red" stroke-width="0.5" vector-effect="non-scaling-stroke" id="frame_alignment" />
</svg>`;
                        const filename = `${safeProjName}_${layer.name}_V23_${dateStr}.svg`;
                        downloadStringAsFile(layerSVG, filename);
                    } else {
                        console.warn("Aucune g√©om√©trie pour " + layer.name);
                    }

                } catch (e) {
                    console.error(e);
                    errorCount++;
                    status.textContent = "‚ùå Echec sur " + layer.name + " " + e.message;
                    await new Promise(r => setTimeout(r, 2000));
                }

                await new Promise(r => setTimeout(r, 1000));
            }

            if (errorCount > 0) alert("Attention : " + errorCount + " calque(s) ont √©chou√©.");
            status.textContent = errorCount === 0 ? "‚úÖ Export V21 Termin√© !" : "‚ö†Ô∏è Termin√© avec erreurs.";
        }

        function metersPerPx(maxLat, minLat) {
            return ((maxLat - minLat) * 111320) / 1000;
        }

        // --- GEOMETRY PROCESSOR (V22: Buffering & Smoothing) ---
        function processLayerGeometry(data, layer, maskPolygon, projectFn, mPerPx, shouldMerge, useBuffer, bufferRadius) {
            if (!data.elements) return "";

            let parts = [];
            let compoundD = "";

            // 1. Convert to Turf Features / Buffer if needed
            let features = [];
            data.elements.forEach(el => {
                if (!el.geometry || el.geometry.length < 2) return;
                const coords = el.geometry.map(p => [p.lon, p.lat]);

                if (layer.fill || (layer.type === 'eau')) {
                    // WATER LOGIC (Keep V18)
                    const isLinearWater = (layer.type === 'eau' && (el.tags.waterway === 'river' || el.tags.waterway === 'canal' || el.tags.waterway === 'stream'));
                    if (isLinearWater) {
                        let pxWidth = 8;
                        if (el.tags.waterway === 'river') pxWidth = 25;
                        if (el.tags.waterway === 'canal') pxWidth = 15;
                        try {
                            const line = turf.lineString(coords);
                            const buf = turf.buffer(line, (pxWidth * mPerPx) / 2, { units: 'meters', steps: 16 });
                            features.push(buf);
                        } catch (e) { }
                    } else {
                        if (coords.length > 2) {
                            if (coords[0][0] !== coords[coords.length - 1][0]) coords.push(coords[0]);
                            try { features.push(turf.polygon([coords])); } catch (e) { }
                        }
                    }
                }
                else {
                    // ROADS LOGIC
                    try {
                        const line = turf.lineString(coords);
                        if (useBuffer) {
                            // Convert Line to Buffered Polygon
                            const cleanLine = turf.cleanCoords(line);
                            const buf = turf.buffer(cleanLine, bufferRadius, { units: 'meters', steps: 32 });
                            features.push(buf);
                        } else {
                            features.push(line);
                        }
                    } catch (e) { }
                }
            });

            // 2. UNION (Water OR Buffered Roads)
            // Warning: Huge Union on roads is slow. We attempt it.
            if ((layer.type === 'eau' || useBuffer) && features.length > 0) {
                try {
                    // Performance Hack: Union in batches of 50 to avoid stack overflow? 
                    // Or just try simplistic loop.
                    if (features.length > 3000) {
                        console.warn("Trop d'√©l√©ments pour Union (" + features.length + "). Skip Union.");
                        // If we skip union, we just draw overlapping polys.
                    } else {
                        let merged = features[0];
                        for (let i = 1; i < features.length; i++) {
                            merged = turf.union(merged, features[i]);
                        }

                        // V22: Clean Result
                        merged = turf.cleanCoords(merged);
                        // Optional: Very slight simplification to remove artifacts, but be careful not to distort
                        merged = turf.simplify(merged, { tolerance: 0.000001, highQuality: true });

                        features = [merged];
                    }
                } catch (e) { console.warn("Union failed", e); }
            }

            // 3. HARD CLIP (INTERSECTION)
            features.forEach(f => {
                if (!f) return;
                try {
                    let geometryToDraw = null;
                    const type = f.geometry.type;

                    if (type === 'Polygon' || type === 'MultiPolygon') {
                        geometryToDraw = turf.intersect(f, maskPolygon);
                    }
                    else if (type === 'LineString') {
                        // (Only if not buffered)
                        if (turf.booleanWithin(f, maskPolygon)) {
                            geometryToDraw = f;
                        } else {
                            const split = turf.lineSplit(f, maskPolygon);
                            if (split.features.length > 0) {
                                split.features.forEach(seg => {
                                    if (turf.booleanPointInPolygon(turf.midpoint(seg), maskPolygon)) {
                                        processFeatureToPath(seg, projectFn, shouldMerge, parts, (d) => compoundD += d + " ");
                                    }
                                });
                                return;
                            } else if (turf.booleanIntersects(f, maskPolygon)) geometryToDraw = f;
                        }
                    }

                    if (geometryToDraw) {
                        processFeatureToPath(geometryToDraw, projectFn, shouldMerge, parts, (d) => compoundD += d + " ");
                    }
                } catch (e) { }
            });

            if (shouldMerge && compoundD.trim() !== "") {
                // If buffered (Fill), we don't need fill=none. Code handles type check.
                return `<path d="${compoundD}" vector-effect="non-scaling-stroke" />`;
            } else {
                return parts.join("\n");
            }
        }

        // Helper: Meters/Px
        function metersPerPx(maxLat, minLat) {
            return ((maxLat - minLat) * 111320) / 1000;
        }

        // --- GEOMETRY PROCESSOR (CLIPPING) ---
        function processLayerGeometry(data, layer, maskPolygon, projectFn, mPerPx, shouldMerge) {
            if (!data.elements) return "";

            let parts = []; // SVG Paths
            let compoundD = ""; // Accumulator for merged path

            // 1. Convert to Turf Features
            let features = [];
            data.elements.forEach(el => {
                if (!el.geometry || el.geometry.length < 2) return;
                const coords = el.geometry.map(p => [p.lon, p.lat]);

                // Water/Buildings -> Polygons
                if (layer.fill || (layer.type === 'eau')) {
                    // logic for Water buffering (V12)
                    const isLinearWater = (layer.type === 'eau' && (el.tags.waterway === 'river' || el.tags.waterway === 'canal' || el.tags.waterway === 'stream'));

                    if (isLinearWater) {
                        let pxWidth = 8;
                        if (el.tags.waterway === 'river') pxWidth = 25;
                        if (el.tags.waterway === 'canal') pxWidth = 15;
                        try {
                            const line = turf.lineString(coords);
                            const buf = turf.buffer(line, (pxWidth * mPerPx) / 2, { units: 'meters' });
                            features.push(buf);
                        } catch (e) { }
                    } else {
                        // Normal Polygon (Lake/Building)
                        if (coords.length > 2) {
                            if (coords[0][0] !== coords[coords.length - 1][0]) coords.push(coords[0]);
                            try { features.push(turf.polygon([coords])); } catch (e) { }
                        }
                    }
                }
                else {
                    // Roads -> LineStrings
                    try { features.push(turf.lineString(coords)); } catch (e) { }
                }
            });

            // 2. UNION (For Water Only)
            if (layer.type === 'eau' && features.length > 0) {
                try {
                    let merged = features[0];
                    for (let i = 1; i < features.length; i++) merged = turf.union(merged, features[i]);
                    features = [merged]; // Keep only the merged result
                } catch (e) { }
            }

            // 3. HARD CLIP (INTERSECTION)
            features.forEach(f => {
                if (!f) return;

                try {
                    let geometryToDraw = null;

                    if (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon') {
                        // Polygon Clipping
                        geometryToDraw = turf.intersect(f, maskPolygon);
                    }
                    else if (f.geometry.type === 'LineString') {
                        // Line Clipping
                        if (turf.booleanWithin(f, maskPolygon)) {
                            geometryToDraw = f;
                        } else {
                            // Split logic with Fallback
                            const split = turf.lineSplit(f, maskPolygon);
                            let segments = [];
                            if (split.features.length > 0) segments = split.features;
                            else {
                                // Split failed? Or Line intersects but split returns nothing?
                                // Fallback: If it intersects, just keep the whole line for now (Safer than deleting)
                                // But user wants clipping.
                                // If booleanIntersects(f, maskPolygon) is true, we should try to keep it.
                                if (turf.booleanIntersects(f, maskPolygon)) segments = [f];
                            }

                            segments.forEach(seg => {
                                const mid = turf.midpoint(seg);
                                if (turf.booleanPointInPolygon(mid, maskPolygon)) {
                                    // Process this segment
                                    processFeatureToPath(seg, projectFn, shouldMerge, parts, (d) => compoundD += d + " ");
                                }
                            });
                            return; // Skip standard processing for split lines
                        }
                    }

                    if (geometryToDraw) {
                        processFeatureToPath(geometryToDraw, projectFn, shouldMerge, parts, (d) => compoundD += d + " ");
                    }

                } catch (e) {
                    // On geometric error, fallback to keeping the original if it touches the box
                    // console.warn("Geo error", e); 
                }
            });

            if (shouldMerge && compoundD.trim() !== "") {
                // Return ONE path
                return `<path d="${compoundD}" vector-effect="non-scaling-stroke" />`;
            } else {
                return parts.join("\n");
            }
        }

        function processFeatureToPath(feature, projectFn, shouldMerge, partsList, onCompound) {
            turf.flatten(feature).features.forEach(f => {
                const coords = f.geometry.coordinates;
                const type = f.geometry.type;
                let d = "";

                if (type === 'Polygon') {
                    coords.forEach(ring => {
                        ring.forEach((pt, i) => {
                            const [px, py] = projectFn(pt[1], pt[0]);
                            d += (i === 0 ? "M " : " L ") + px.toFixed(2) + " " + py.toFixed(2);
                        });
                        d += " Z ";
                    });
                }
                else if (type === 'LineString') {
                    coords.forEach((pt, i) => {
                        const [px, py] = projectFn(pt[1], pt[0]);
                        d += (i === 0 ? "M " : " L ") + px.toFixed(2) + " " + py.toFixed(2);
                    });
                    // Lines don't close automatically
                }

                if (shouldMerge) {
                    onCompound(d);
                } else {
                    partsList.push(`<path d="${d}" fill="${type === 'Polygon' ? 'black' : 'none'}" vector-effect="non-scaling-stroke" />`);
                }
            });
        }

        function downloadStringAsFile(content, filename) {
            const blob = new Blob([content], { type: 'image/svg+xml' });
            const link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }
    </script>
</body>

</html>
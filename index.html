<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur Carte OSM (Vectoriel)</title>

    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Plugin Recherche (GeoSearch) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

    <!-- Leaflet Draw CSS & JS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

    <!-- Turf.js for Geometry -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

    <style>
        :root {
            --primary: #8b5cf6;
            --surface: #ffffff;
            --background: #f3f4f6;
            --text: #1f2937;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            height: 100vh;
            display: flex;
            background-color: var(--background);
            color: var(--text);
            overflow: hidden;
        }

        #sidebar {
            width: 380px;
            background-color: var(--surface);
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        h1 {
            font-size: 1.25rem;
            margin-top: 0;
            color: var(--primary);
            font-weight: 700;
        }

        .control-group {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e5e7eb;
        }

        .info {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 5px;
            line-height: 1.4;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            width: 100%;
            transition: background-color 0.2s;
            margin-bottom: 8px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
        }

        button:hover {
            background-color: #7c3aed;
        }

        button.secondary {
            background-color: #e5e7eb;
            color: #374151;
        }

        button.secondary:hover {
            background-color: #d1d5db;
        }

        /* Checkbox List Styles */
        .layer-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: #f9fafb;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .layer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
        }

        .layer-item:hover {
            background-color: #f3f4f6;
        }

        .layer-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .badge {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 10px;
            background: #e5e7eb;
            color: #4b5563;
            margin-left: auto;
        }

        #map {
            flex-grow: 1;
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        .leaflet-control-geocoder {
            z-index: 2000;
        }
    </style>
</head>

<body>

    <div id="sidebar">
        <h1>Carte Laser (OSM) V15 ‚¨†</h1>

        <!-- Nom du Projet -->
        <div style="margin-bottom: 20px;">
            <label style="font-size: 0.9rem; font-weight: 600;">Nom du Projet</label>
            <input type="text" id="projectName" placeholder="Ex: Paris 12e..."
                style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;">
        </div>

        <div class="control-group">
            <h3>1. Localisation</h3>
            <div class="info">Utilisez la loupe sur la carte pour chercher une ville.</div>
        </div>

        <div class="control-group">
            <h3>2. Zone de D√©coupe</h3>
            <div style="display: flex; gap: 10px; margin-bottom:10px;">
                <button onclick="initPentagon()" style="background-color: #d946ef;">
                    ‚¨† Pentagone
                </button>
                <button onclick="drawRectangle()" class="secondary">
                    ‚¨õ Carr√©
                </button>
            </div>

            <!-- Slider Taille -->
            <div style="margin-top: 5px;">
                <div style="display:flex; justify-content:space-between;">
                    <label style="font-size: 0.9rem; font-weight: 600;">Taille</label>
                    <span id="radiusVal" style="font-size: 0.8rem; color:#666;">2.0 km</span>
                </div>
                <input type="range" id="radiusInput" min="500" max="15000" step="100" value="2000"
                    style="width: 100%; accent-color: #d946ef;" oninput="updatePentagonTransform()">
            </div>

            <!-- Slider Rotation -->
            <div style="margin-top: 10px;">
                <div style="display:flex; justify-content:space-between;">
                    <label style="font-size: 0.9rem; font-weight: 600;">Rotation</label>
                    <span id="rotVal" style="font-size: 0.8rem; color:#666;">0¬∞</span>
                </div>
                <input type="range" id="rotInput" min="0" max="360" step="5" value="0"
                    style="width: 100%; accent-color: #d946ef;" oninput="updatePentagonTransform()">
            </div>

            <div id="zone-status" class="info" style="color: red;">Aucune zone dessin√©e.</div>
        </div>

        <div class="control-group">
            <h3>3. S√©lectionner les Couches</h3>
            <div class="info" style="margin-bottom:10px;">
                Cochez les √©l√©ments √† inclure dans le t√©l√©chargement.
            </div>

            <div class="layer-list">
                <label class="layer-item">
                    <input type="checkbox" id="chk_routes_grands" checked>
                    <span>üõ£Ô∏è Autoroutes & Nationales</span>
                    <span class="badge">√âpais</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_routes_secondaires" checked>
                    <span>üöó Routes Principales</span>
                    <span class="badge">Moyen</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_routes_locales" checked>
                    <span>üèòÔ∏è Rues Locales</span>
                    <span class="badge">Fin</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_eau" checked>
                    <span>üíß Fleuves & Lacs</span>
                    <span class="badge">Rempli</span>
                </label>
                <label class="layer-item">
                    <input type="checkbox" id="chk_bati">
                    <span>üè¢ B√¢timents</span>
                    <span class="badge">Lourd</span>
                </label>
            </div>

            <br>
            <button onclick="downloadSelectedLayers()" style="font-size: 1.1rem; padding: 15px;">
                ‚¨áÔ∏è T√âL√âCHARGER LA S√âLECTION
            </button>

            <div id="global-status" class="info" style="font-weight: bold; color: var(--primary); margin-top:10px;">
            </div>
        </div>

        <div class="control-group">
            <h3>4. Rendu Visuel</h3>
            <div style="display:flex; gap:10px">
                <button class="secondary" onclick="setLayer('light')">Blanc</button>
                <button class="secondary" onclick="setLayer('dark')">Noir</button>
            </div>
        </div>

    </div>

    <div id="map"></div>

    <script>
        // Init Map
        const map = L.map('map').setView([48.8566, 2.3522], 13);

        // Layers
        const layers = {
            osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM' }),
            light: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; CartoDB' }),
            dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; CartoDB' })
        };
        layers.light.addTo(map);

        function setLayer(name) {
            map.eachLayer(layer => {
                if (layer._url) map.removeLayer(layer);
            });
            layers[name].addTo(map);
        }

        // Search
        L.Control.geocoder({ defaultMarkGeocode: false })
            .on('markgeocode', function (e) {
                const bbox = e.geocode.bbox;
                const poly = L.polygon([bbox.getSouthEast(), bbox.getNorthEast(), bbox.getNorthWest(), bbox.getSouthWest()]);
                map.fitBounds(poly.getBounds());
            })
            .addTo(map);

        // --- DRAW FEATURE ---
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        let selectedBounds = null;
        let selectedShapeLayer = null;
        let isPentagonActive = false;
        let pentagonCenter = null;

        function drawRectangle() {
            isPentagonActive = false;
            pentagonCenter = null;
            new L.Draw.Rectangle(map, { shapeOptions: { color: '#2563eb' } }).enable();
        }

        function updatePentagonTransform() {
            const r = document.getElementById('radiusInput').value;
            const rot = document.getElementById('rotInput').value;

            document.getElementById('radiusVal').textContent = (r / 1000).toFixed(1) + " km";
            document.getElementById('rotVal').textContent = rot + "¬∞";

            if (isPentagonActive && pentagonCenter) {
                drawPentagon(pentagonCenter);
            }
        }

        function initPentagon() {
            const center = map.getCenter();
            drawPentagon(center);
        }

        // --- PENTAGON LOGIC (RESIZABLE + ROTATABLE) ---
        function drawPentagon(center) {
            drawnItems.clearLayers();
            pentagonCenter = center;

            // Radius from slider
            const rMeters = parseInt(document.getElementById('radiusInput').value);
            const radiusDeg = rMeters / 111320;

            // Rotation from slider (deg -> rad)
            const rotDeg = parseInt(document.getElementById('rotInput').value);
            const rotRad = rotDeg * (Math.PI / 180);

            const points = [];
            const sides = 5;
            const baseRot = -Math.PI / 2; // Point up default

            for (let i = 0; i < sides; i++) {
                const angle = (i * 2 * Math.PI) / sides + baseRot + rotRad;
                const latOffset = radiusDeg * Math.sin(angle);
                const lonOffset = (radiusDeg * Math.cos(angle)) / Math.cos(center.lat * Math.PI / 180);

                points.push([center.lat + latOffset, center.lng + lonOffset]);
            }
            const polygon = L.polygon(points, { color: '#d946ef', weight: 3 });
            drawnItems.addLayer(polygon);
            selectedShapeLayer = polygon;
            selectedBounds = polygon.getBounds();

            isPentagonActive = true;
            document.getElementById('zone-status').innerHTML = "‚¨† Pentagone Actif (" + (rMeters / 1000) + "km)";
            document.getElementById('zone-status').style.color = "#d946ef";
        }

        // Events
        map.on(L.Draw.Event.CREATED, function (e) {
            drawnItems.clearLayers();
            drawnItems.addLayer(e.layer);
            selectedShapeLayer = e.layer;
            selectedBounds = e.layer.getBounds();
            isPentagonActive = false;
            document.getElementById('zone-status').innerHTML = "‚úÖ Zone Valide (Manuel)";
            document.getElementById('zone-status').style.color = "green";
        });


        // --- SINGLE FILE EXPORT LOGIC (DESTRUCTIVE CLIP) ---

        async function downloadSelectedLayers() {
            if (map.getZoom() < 12) {
                if (!confirm("‚ö†Ô∏è ATTENTION : Zone tr√®s large.\nRisque de Timeout serveur.\nVoulez-vous continuer ?")) return;
            }

            // 1. Define Clipping Mask & Overpass Filter
            let maskPolygon = null;
            let overpassFilter = "";

            if (selectedShapeLayer && selectedShapeLayer instanceof L.Polygon) {
                // Polygon Mask
                const latlngs = selectedShapeLayer.getLatLngs()[0];
                const coords = latlngs.map(pt => [pt.lng, pt.lat]);
                if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {
                    coords.push(coords[0]);
                }
                maskPolygon = turf.polygon([coords]);

                // Overpass Poly String: "lat1 lon1 lat2 lon2 ..."
                const polyStr = latlngs.map(pt => `${pt.lat} ${pt.lng}`).join(" ");
                overpassFilter = `(poly:"${polyStr}")`;
            } else {
                // Fallback to Bounds Rect
                const b = selectedBounds || map.getBounds();
                maskPolygon = turf.bboxPolygon([b.getWest(), b.getSouth(), b.getEast(), b.getNorth()]);
                overpassFilter = `(${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()})`;
            }

            const layers = [
                { id: 'chk_eau', type: 'eau', name: 'Eau', color: 'blue', fill: true },
                { id: 'chk_routes_locales', type: 'routes_locales', name: 'Rues', color: 'black', width: 1 },
                { id: 'chk_routes_secondaires', type: 'routes_secondaires', name: 'Routes_Principales', color: 'orange', width: 3 },
                { id: 'chk_routes_grands', type: 'routes_grands', name: 'Autoroutes', color: 'red', width: 5 },
                { id: 'chk_bati', type: 'bati', name: 'Batiments', color: 'black', fill: true }
            ];

            const activeLayers = layers.filter(l => document.getElementById(l.id).checked);

            if (activeLayers.length === 0) {
                alert("Veuillez cocher au moins une couche !");
                return;
            }

            const status = document.getElementById("global-status");
            status.textContent = "D√©marrage V15...";

            // Prepare SVG Dimensions
            const bounds = selectedBounds || map.getBounds();
            const minLat = bounds.getSouth();
            const maxLat = bounds.getNorth();
            const minLon = bounds.getWest();
            const maxLon = bounds.getEast();
            const widthSvg = 1000 * ((maxLon - minLon) / (maxLat - minLat)) * Math.cos((minLat + maxLat) / 2 * Math.PI / 180);
            const heightSvg = 1000;

            function project(lat, lon) {
                const px = ((lon - minLon) / (maxLon - minLon)) * widthSvg;
                const py = 1000 - ((lat - minLat) / (maxLat - minLat) * 1000);
                return [px, py];
            }

            let svgGroups = [];
            let errorCount = 0;

            // 2. Fetch & Process Each Layer
            for (const layer of activeLayers) {
                status.textContent = "T√©l√©chargement : " + layer.name + "...";

                let queryType = "";
                if (layer.type === 'routes_grands') queryType = `way["highway"~"motorway|trunk|primary"]`;
                else if (layer.type === 'routes_secondaires') queryType = `way["highway"~"secondary|tertiary"]`;
                else if (layer.type === 'routes_locales') queryType = `way["highway"~"residential|unclassified|living_street"]`;
                else if (layer.type === 'eau') queryType = `way["natural"="water"]; way["waterway"]`;
                else if (layer.type === 'bati') queryType = `way["building"]`;

                // Handle special case for double query (water)
                let queryBody = "";
                if (layer.type === 'eau') {
                    // Split by semicolon and apply filter to each
                    queryBody = `way["natural"="water"]${overpassFilter}; way["waterway"]${overpassFilter};`;
                } else {
                    queryBody = `${queryType}${overpassFilter};`;
                }

                const query = `[out:json][timeout:300]; (${queryBody}); out geom tags;`;

                try {
                    const resp = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
                    if (!resp.ok) throw new Error("Erreur HTTP " + resp.status);
                    const data = await resp.json();

                    status.textContent = `${layer.name}: ${data.elements ? data.elements.length : 0} objets...`;

                    // Generate Geometry
                    const groupContent = processLayerGeometry(data, layer, maskPolygon, project, metersPerPx(maxLat, minLat));
                    if (groupContent) {
                        svgGroups.push(`<g id="${layer.name}" stroke="${layer.color}" fill="${layer.fill ? layer.color : 'none'}" stroke-width="${layer.width || 1}">\n${groupContent}\n</g>`);
                    }

                } catch (e) {
                    console.error(e);
                    errorCount++;
                    status.textContent = "‚ùå Echec sur " + layer.name + " (Timeout ?)";
                    await new Promise(r => setTimeout(r, 2000));
                }

                await new Promise(r => setTimeout(r, 500));
            }

            if (errorCount > 0) alert("Attention : " + errorCount + " calque(s) ont √©chou√© (Trop de donn√©es / Timeout Serveur). R√©essayez une zone plus petite.");

            // 3. Assemble Final SVG
            const safeProjName = (document.getElementById('projectName').value || "Carte_Laser").replace(/[^a-z0-9]/gi, '_');
            const dateStr = new Date().toISOString().split('T')[0];
            const filename = `${safeProjName}_V15_${dateStr}.svg`;

            const finalSVG = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ${widthSvg.toFixed(2)} ${heightSvg}">
  ${svgGroups.join("\n")}
</svg>`;

            downloadStringAsFile(finalSVG, filename);
            status.textContent = errorCount === 0 ? "‚úÖ Export V15 Termin√© !" : "‚ö†Ô∏è Termin√© avec erreurs.";
        }

        // Helper: Meters/Px
        function metersPerPx(maxLat, minLat) {
            return ((maxLat - minLat) * 111320) / 1000;
        }

        // --- GEOMETRY PROCESSOR (CLIPPING) ---
        function processLayerGeometry(data, layer, maskPolygon, projectFn, mPerPx) {
            if (!data.elements) return "";

            let parts = []; // SVG Paths

            // 1. Convert to Turf Features
            let features = [];
            data.elements.forEach(el => {
                if (!el.geometry || el.geometry.length < 2) return;
                const coords = el.geometry.map(p => [p.lon, p.lat]);

                // Water/Buildings -> Polygons
                if (layer.fill || (layer.type === 'eau')) {
                    // logic for Water buffering (V12)
                    const isLinearWater = (layer.type === 'eau' && (el.tags.waterway === 'river' || el.tags.waterway === 'canal' || el.tags.waterway === 'stream'));

                    if (isLinearWater) {
                        let pxWidth = 8;
                        if (el.tags.waterway === 'river') pxWidth = 25;
                        if (el.tags.waterway === 'canal') pxWidth = 15;
                        try {
                            const line = turf.lineString(coords);
                            const buf = turf.buffer(line, (pxWidth * mPerPx) / 2, { units: 'meters' });
                            features.push(buf);
                        } catch (e) { }
                    } else {
                        // Normal Polygon (Lake/Building)
                        if (coords.length > 2) {
                            if (coords[0][0] !== coords[coords.length - 1][0]) coords.push(coords[0]);
                            try { features.push(turf.polygon([coords])); } catch (e) { }
                        }
                    }
                }
                else {
                    // Roads -> LineStrings
                    try { features.push(turf.lineString(coords)); } catch (e) { }
                }
            });

            // 2. UNION (For Water Only)
            if (layer.type === 'eau' && features.length > 0) {
                try {
                    let merged = features[0];
                    for (let i = 1; i < features.length; i++) merged = turf.union(merged, features[i]);
                    features = [merged]; // Keep only the merged result
                } catch (e) { }
            }

            // 3. HARD CLIP (INTERSECTION)
            features.forEach(f => {
                if (!f) return;

                try {
                    if (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon') {
                        // Polygon Clipping
                        const clipped = turf.intersect(f, maskPolygon);
                        if (clipped) drawFeature(clipped, parts, projectFn);
                    }
                    else if (f.geometry.type === 'LineString') {
                        // Line Clipping
                        if (turf.booleanWithin(f, maskPolygon)) {
                            drawFeature(f, parts, projectFn);
                        } else {
                            // Split logic with Fallback
                            const split = turf.lineSplit(f, maskPolygon);
                            let segments = [];
                            if (split.features.length > 0) segments = split.features;
                            else {
                                // Split failed? Or Line intersects but split returns nothing?
                                // Fallback: If it intersects, just keep the whole line for now (Safer than deleting)
                                // But user wants clipping.
                                // If booleanIntersects(f, maskPolygon) is true, we should try to keep it.
                                if (turf.booleanIntersects(f, maskPolygon)) segments = [f];
                            }

                            segments.forEach(seg => {
                                const mid = turf.midpoint(seg);
                                if (turf.booleanPointInPolygon(mid, maskPolygon)) {
                                    drawFeature(seg, parts, projectFn);
                                }
                            });
                        }
                    }
                } catch (e) {
                    // On geometric error, fallback to keeping the original if it touches the box
                    // console.warn("Geo error", e); 
                }
            });

            return parts.join("\n");
        }

        function drawFeature(feature, parts, projectFn) {
            const geoms = (feature.geometry.type === 'MultiPolygon' || feature.geometry.type === 'MultiLineString')
                ? feature.geometry.coordinates
                : [feature.geometry.coordinates];

            // Helper to recursively handle multi-depth
            // Polygon: [[Ring], [Hole]] -> Ring is [pt, pt]
            // MultiPolygon: [[[Ring], [Hole]], [[Ring]]]
            // LineString: [pt, pt]

            // Unify structure traversal is annoying. Simplification:
            turf.flatten(feature).features.forEach(f => {
                const coords = f.geometry.coordinates;
                const type = f.geometry.type;

                if (type === 'Polygon') {
                    coords.forEach(ring => {
                        let d = "";
                        ring.forEach((pt, i) => {
                            const [px, py] = projectFn(pt[1], pt[0]);
                            d += (i === 0 ? "M " : " L ") + px.toFixed(2) + " " + py.toFixed(2);
                        });
                        d += " Z";
                        parts.push(`<path d="${d}" vector-effect="non-scaling-stroke" />`);
                    });
                }
                else if (type === 'LineString') {
                    let d = "";
                    coords.forEach((pt, i) => {
                        const [px, py] = projectFn(pt[1], pt[0]);
                        d += (i === 0 ? "M " : " L ") + px.toFixed(2) + " " + py.toFixed(2);
                    });
                    parts.push(`<path d="${d}" fill="none" vector-effect="non-scaling-stroke" />`);
                }
            });
        }

        function downloadStringAsFile(content, filename) {
            const blob = new Blob([content], { type: 'image/svg+xml' });
            const link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }
    </script>
</body>

</html>